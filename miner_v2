-- SmartMiner Turtle V2 - A* Pathfinding Client
-- Works with computer brain for coordinated mining

----------------------------------
-- CONFIGURATION
----------------------------------
local COMPUTER_ID = 3                -- ID of the computer brain
local PROTOCOL = "smartminer"        -- Must match computer
local TURTLE_ID = os.getComputerID and os.getComputerID() or 2

-- ORE FILTER: Which ores to mine (set to nil to mine ALL ores)
local ORE_FILTER = {
    "iron",      -- Mine iron ore
    "coal",      -- Mine coal ore
    "gold",      -- Mine gold ore
    "diamond",   -- Mine diamond ore
    -- "copper",    -- Uncomment to mine copper
    -- "redstone",  -- Uncomment to mine redstone
    -- "lapis",     -- Uncomment to mine lapis
    -- "emerald",   -- Uncomment to mine emerald
}
-- Set to nil to mine ALL ore types: local ORE_FILTER = nil

----------------------------------
-- MOVEMENT STATISTICS
----------------------------------
local stats = {
    blocksMinedForward = 0,
    blocksMinedUp = 0,
    blocksMinedDown = 0,
    freeMoves = 0,
    totalMoves = 0,
    oresMined = 0,
    pathsReceived = 0,
    scansRequested = 0,
}

----------------------------------
-- MODEM AUTO-DETECTION
----------------------------------
local function findAndOpenModem()
    -- Try to find wireless modem on any side
    for _, side in ipairs({"right", "left", "top", "bottom", "front", "back"}) do
        if peripheral.getType(side) and peripheral.getType(side):find("modem") then
            local m = peripheral.wrap(side)
            if m.isWireless and m.isWireless() then
                rednet.open(side)
                print("Modem found on:", side)
                return true
            end
        end
    end
    return false
end

if not findAndOpenModem() then
    error("ERROR: No wireless modem found!")
end

----------------------------------
-- GPS AND POSITION TRACKING
----------------------------------
local gps = gps  -- Use built-in GPS
local lastKnown = {x=0, y=0, z=0}
local facing = 0  -- 0=north, 1=east, 2=south, 3=west

-- Home position and facing (declared early for saveHomeLocation)
local homePos
local homeFacing

local function getPos()
    -- Try GPS multiple times
    for attempt = 1, 3 do
        local x, y, z = gps.locate(5)
        if x then 
            lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
            return lastKnown
        end
        if attempt < 3 then
            sleep(1)
        end
    end
    -- Fallback to internal tracking (may be inaccurate!)
    return lastKnown
end

----------------------------------
-- PERSISTENT STORAGE
----------------------------------
local HOME_FILE = "home_location.txt"

local function saveHomeLocation(pos, face)
    -- Use global variables if parameters not provided
    pos = pos or homePos
    face = face or homeFacing
    
    if not pos then
        print("✗ Cannot save: No home position")
        return false
    end
    
    local f = fs.open(HOME_FILE, "w")
    if f then
        f.writeLine(textutils.serialize({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            facing = face
        }))
        f.close()
        print("✓ Home location saved")
        return true
    end
    return false
end

local function loadHomeLocation()
    if fs.exists(HOME_FILE) then
        local f = fs.open(HOME_FILE, "r")
        if f then
            local data = f.readAll()
            f.close()
            local ok, result = pcall(function() return textutils.unserialize(data) end)
            if ok and result then
                print("✓ Found saved home location")
                return result
            end
        end
    end
    return nil
end

----------------------------------
-- CHEST DETECTION (SIMPLE)
----------------------------------
-- Use turtle.inspect() to find chest in 4 horizontal directions

local function findChestSimple()
    print("═══════════════════════════════")
    print("  CHEST DETECTION")
    print("═══════════════════════════════")
    print("")
    
    local pos = getPos()
    print(string.format("Turtle position: %d, %d, %d", pos.x, pos.y, pos.z))
    print("Scanning for chest in 4 directions...")
    print("")
    
    -- Scan all 4 horizontal directions
    for dir = 0, 3 do
        local dirName = ({"North", "East", "South", "West"})[dir + 1]
        local success, data = turtle.inspect()
        
        if success and data.name and data.name:find("chest") then
            print(string.format("✓ Found chest: %s", data.name))
            print(string.format("  Direction: %s (facing %d)", dirName, dir))
            
            -- Face away from chest (180 degrees)
            local awayDir = (dir + 2) % 4
            while facing ~= awayDir do
                turtle.turnRight()
                facing = (facing + 1) % 4
            end
            
            print(string.format("✓ Facing away: %s", ({"North", "East", "South", "West"})[awayDir + 1]))
            print(string.format("✓ Home configured: %d, %d, %d", pos.x, pos.y, pos.z))
            print("")
            
            return {
                x = pos.x,
                y = pos.y,
                z = pos.z,
                facing = awayDir
            }
        end
        
        -- Turn right for next direction
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    -- No chest found in any direction
    print("")
    print("✗ ERROR: No chest found in any direction!")
    print("")
    print("Setup:")
    print("  1. Place turtle next to a chest")
    print("  2. Chest must be in front, behind, left, or right")
    print("  3. Chest must be on same Y-level as turtle")
    print("")
    error("No chest found")
end

----------------------------------
-- BASE STATION CHEST SETUP
----------------------------------
print("═══════════════════════════════════")
print("  SMARTMINER TURTLE V2")
print("═══════════════════════════════════")
print("Turtle ID:", TURTLE_ID)
print("Computer ID:", COMPUTER_ID)
print("")

-- Try to load saved home location
local savedHome = loadHomeLocation()

if savedHome then
    -- Auto-load saved location
    homePos = {x=savedHome.x, y=savedHome.y, z=savedHome.z}
    homeFacing = savedHome.facing
    facing = homeFacing
    print(string.format("✓ Loaded home: %d, %d, %d", savedHome.x, savedHome.y, savedHome.z))
    print(string.format("✓ Facing: %s", ({"North","East","South","West"})[homeFacing+1] or "unknown"))
    print("")
else
    -- First time setup - find chest with turtle.inspect()
    print("FIRST TIME SETUP")
    print("")
    
    local detected = findChestSimple()
    
    -- findChestSimple() will error if it fails
    -- So if we reach here, detection succeeded
    homePos = {x=detected.x, y=detected.y, z=detected.z}
    homeFacing = detected.facing
    facing = homeFacing
    
    -- Save configuration
    saveHomeLocation()
    print("✓ Setup complete and saved!")
    print("")
end

print("✓ Setup complete")
print("═══════════════════════════════════")

----------------------------------
-- COMMAND HANDLING (MUST BE BEFORE MOVEMENT FUNCTIONS)
----------------------------------
local returnHomeRequested = false  -- Global flag for immediate return

local function checkCommandsNonBlocking()
    -- Quick check for commands without processing (for use in loops)
    local senderId, message = rednet.receive(PROTOCOL, 0)
    if senderId and message and message.type == "return_home" then
        returnHomeRequested = true
        print("")
        print("════════════════════════════════════════")
        print("*** RETURN HOME command received! ***")
        print("*** Interrupting current operation! ***")
        print("════════════════════════════════════════")
        return true
    end
    return false
end

----------------------------------
-- SMART MOVEMENT FUNCTIONS
----------------------------------
local function tryForward()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.forward() then
        stats.freeMoves = stats.freeMoves + 1
        -- ALWAYS update internal position for dead reckoning
        if facing == 0 then lastKnown.z = lastKnown.z - 1
        elseif facing == 1 then lastKnown.x = lastKnown.x + 1
        elseif facing == 2 then lastKnown.z = lastKnown.z + 1
        elseif facing == 3 then lastKnown.x = lastKnown.x - 1
        end
        return true
    end
    
    -- Blocked - dig and retry
    while not turtle.forward() do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested, aborting movement")
            return false
        end
        
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.dig() then
            stats.blocksMinedForward = stats.blocksMinedForward + 1
        end
        turtle.attack()
        sleep(0.1)
    end
    
    -- ALWAYS update position after successful move
    if facing == 0 then lastKnown.z = lastKnown.z - 1
    elseif facing == 1 then lastKnown.x = lastKnown.x + 1
    elseif facing == 2 then lastKnown.z = lastKnown.z + 1
    elseif facing == 3 then lastKnown.x = lastKnown.x - 1
    end
    return true
end

local function tryUp()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.up() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y + 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.up() do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested, aborting movement")
            return false
        end
        
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspectUp()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected above! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.digUp() then
            stats.blocksMinedUp = stats.blocksMinedUp + 1
        end
        turtle.attackUp()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y + 1  -- Always update
    return true
end

local function tryDown()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.down() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y - 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.down() do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested, aborting movement")
            return false
        end
        
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspectDown()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected below! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.digDown() then
            stats.blocksMinedDown = stats.blocksMinedDown + 1
        end
        turtle.attackDown()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y - 1  -- Always update
    return true
end

----------------------------------
-- DIRECTION CONTROL
----------------------------------
local function turnTo(targetDir)
    while facing ~= targetDir do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
end

----------------------------------
-- ABSOLUTE POSITION MOVEMENT
----------------------------------
local function moveAbs(targetX, targetY, targetZ, _depth)
    _depth = _depth or 0  -- Track recursion depth
    
    if _depth > 2 then
        print("⚠ Max correction attempts reached")
        print("  Position may not be exact")
        return true  -- Stop recursion
    end
    
    print(string.format("→ Moving to: %d, %d, %d", targetX, targetY, targetZ))
    
    -- Get initial GPS position
    local x, y, z = gps.locate(5)
    if x then
        lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
    end
    
    print(string.format("  Starting from: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
    
    -- Show movement plan
    local xMove = targetX - lastKnown.x
    local yMove = targetY - lastKnown.y
    local zMove = targetZ - lastKnown.z
    print(string.format("  Movement needed: X%+d, Y%+d, Z%+d", xMove, yMove, zMove))
    
    if math.abs(xMove) > 0 then
        if xMove > 0 then
            print(string.format("    → Will move East %d blocks (X: %d to %d)", xMove, lastKnown.x, targetX))
        else
            print(string.format("    → Will move West %d blocks (X: %d to %d)", math.abs(xMove), lastKnown.x, targetX))
        end
    end
    
    if math.abs(yMove) > 0 then
        if yMove > 0 then
            print(string.format("    → Will move Up %d blocks (Y: %d to %d)", yMove, lastKnown.y, targetY))
        else
            print(string.format("    → Will move Down %d blocks (Y: %d to %d)", math.abs(yMove), lastKnown.y, targetY))
        end
    end
    
    if math.abs(zMove) > 0 then
        if zMove > 0 then
            print(string.format("    → Will move South %d blocks (Z: %d to %d)", zMove, lastKnown.z, targetZ))
        else
            print(string.format("    → Will move North %d blocks (Z: %d to %d)", math.abs(zMove), lastKnown.z, targetZ))
        end
    end
    
    local moveCount = 0
    local maxMoves = 500
    
    -- Move vertically first (use lastKnown for position)
    while lastKnown.y < targetY and moveCount < maxMoves do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested during Y movement")
            return
        end
        
        tryUp()
        moveCount = moveCount + 1
        
        -- GPS check every 5 blocks to correct drift
        if moveCount % 5 == 0 then
            local gx, gy, gz = gps.locate(5)
            if gx then
                lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                print(string.format("  Y progress: Up %d (GPS: %d, %d, %d)", moveCount, lastKnown.x, lastKnown.y, lastKnown.z))
            end
        end
    end
    
    moveCount = 0
    while lastKnown.y > targetY and moveCount < maxMoves do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested during Y movement")
            return
        end
        
        tryDown()
        moveCount = moveCount + 1
        
        -- GPS check every 5 blocks to correct drift
        if moveCount % 5 == 0 then
            local gx, gy, gz = gps.locate(5)
            if gx then
                lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                print(string.format("  Y progress: Down %d (GPS: %d, %d, %d)", moveCount, lastKnown.x, lastKnown.y, lastKnown.z))
            end
        end
    end
    
    -- Move on X axis with smart obstacle avoidance
    moveCount = 0
    local failCount = 0
    
    -- GPS check before X movement
    local gx, gy, gz = gps.locate(5)
    if gx then
        lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
        print(string.format("X-axis start: Current=%d, Target=%d, Diff=%d", lastKnown.x, targetX, targetX - lastKnown.x))
    end
    
    local lastDistance = math.abs(targetX - lastKnown.x)
    
    while lastKnown.x ~= targetX and moveCount < maxMoves do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested during X movement")
            return
        end
        
        -- Recalculate direction based on current position
        local xDiff = targetX - lastKnown.x
        if xDiff > 0 then 
            turnTo(1)  -- East (X+)
            if moveCount == 0 then
                print(string.format("  Moving East %d blocks... (facing=%d, expecting X to INCREASE)", xDiff, facing))
            end
        elseif xDiff < 0 then 
            turnTo(3)  -- West (X-)
            if moveCount == 0 then
                print(string.format("  Moving West %d blocks... (facing=%d, expecting X to DECREASE)", math.abs(xDiff), facing))
            end
        else
            break  -- Already at target X
        end
        
        local success = tryForward()
        
        -- Verify direction after first move
        if success and moveCount == 0 then
            local vx, vy, vz = gps.locate(5)
            if vx then
                local actualX = math.floor(vx)
                local actualZ = math.floor(vz)
                local oldX = lastKnown.x
                local oldZ = lastKnown.z
                
                print(string.format("    Direction check: X %d→%d, Z %d→%d", oldX, actualX, oldZ, actualZ))
                
                -- Check if we moved on the correct axis (X should change, Z should NOT)
                local xChanged = (actualX ~= oldX)
                local zChanged = (actualZ ~= oldZ)
                
                if not xChanged and zChanged then
                    print("    ✗✗ CRITICAL ERROR: Moving on Z axis instead of X!")
                    print("    ✗✗ Direction mapping is WRONG!")
                    print("    Stopping X movement...")
                    break  -- Exit X movement loop
                end
                
                if (xDiff > 0 and actualX <= oldX) or (xDiff < 0 and actualX >= oldX) then
                    print("    ✗ WRONG DIRECTION on X axis!")
                    print("    Turning around...")
                    turtle.turnRight()
                    turtle.turnRight()
                    facing = (facing + 2) % 4
                end
                lastKnown = {x=actualX, y=math.floor(vy), z=actualZ}
            end
        end
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- GPS check every 5 blocks to correct drift
            if moveCount % 5 == 0 then
                local gx, gy, gz = gps.locate(5)
                if gx then
                    local oldPos = lastKnown
                    lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                    local remaining = math.abs(targetX - lastKnown.x)
                    print(string.format("  X progress: %d (GPS: %d, %d, %d) - %d blocks to go", moveCount, lastKnown.x, lastKnown.y, lastKnown.z, remaining))
                    
                    -- CRITICAL: Check if distance is INCREASING (moving wrong way!)
                    if remaining > lastDistance + 2 then
                        print("  ✗ ERROR: Moving AWAY from target!")
                        print(string.format("    Was %d blocks away, now %d blocks away", lastDistance, remaining))
                        print("    Direction is WRONG! Breaking out...")
                        break  -- Exit loop and recalculate
                    end
                    lastDistance = remaining
                    
                    -- Check if we need to change direction
                    if (oldPos.x < targetX) ~= (lastKnown.x < targetX) then
                        print("  ⚠ Correcting direction...")
                    end
                else
                    print(string.format("  X progress: %d", moveCount))
                end
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(xDiff) > 0 and moveCount >= math.abs(xDiff) + 5 then
            print("  X: Reached expected distance")
            break
        end
    end
    
    -- Move on Z axis with smart obstacle avoidance
    moveCount = 0
    failCount = 0
    
    -- GPS check before Z movement
    local gx, gy, gz = gps.locate(5)
    if gx then
        lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
        print(string.format("Z-axis start: Current=%d, Target=%d, Diff=%d", lastKnown.z, targetZ, targetZ - lastKnown.z))
    end
    
    local lastDistance = math.abs(targetZ - lastKnown.z)
    
    while lastKnown.z ~= targetZ and moveCount < maxMoves do
        -- Check for return home command
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested during Z movement")
            return
        end
        
        -- Recalculate direction based on current position
        local zDiff = targetZ - lastKnown.z
        if zDiff > 0 then 
            turnTo(2)  -- South (Z+)
            if moveCount == 0 then
                print(string.format("  Moving South %d blocks... (facing=%d, expecting Z to INCREASE)", zDiff, facing))
            end
        elseif zDiff < 0 then 
            turnTo(0)  -- North (Z-)
            if moveCount == 0 then
                print(string.format("  Moving North %d blocks... (facing=%d, expecting Z to DECREASE)", math.abs(zDiff), facing))
            end
        else
            break  -- Already at target Z
        end
        
        local success = tryForward()
        
        -- Verify direction after first move
        if success and moveCount == 0 then
            local vx, vy, vz = gps.locate(5)
            if vx then
                local actualX = math.floor(vx)
                local actualZ = math.floor(vz)
                local oldX = lastKnown.x
                local oldZ = lastKnown.z
                
                print(string.format("    Direction check: X %d→%d, Z %d→%d", oldX, actualX, oldZ, actualZ))
                
                -- Check if we moved on the correct axis (Z should change, X should NOT)
                local xChanged = (actualX ~= oldX)
                local zChanged = (actualZ ~= oldZ)
                
                if xChanged and not zChanged then
                    print("    ✗✗ CRITICAL ERROR: Moving on X axis instead of Z!")
                    print("    ✗✗ Direction mapping is WRONG!")
                    print("    Stopping Z movement...")
                    break  -- Exit Z movement loop
                end
                
                if (zDiff > 0 and actualZ <= oldZ) or (zDiff < 0 and actualZ >= oldZ) then
                    print("    ✗ WRONG DIRECTION on Z axis!")
                    print("    Turning around...")
                    turtle.turnRight()
                    turtle.turnRight()
                    facing = (facing + 2) % 4
                end
                lastKnown = {x=actualX, y=math.floor(vy), z=actualZ}
            end
        end
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- GPS check every 5 blocks to correct drift
            if moveCount % 5 == 0 then
                local gx, gy, gz = gps.locate(5)
                if gx then
                    local oldPos = lastKnown
                    lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                    local remaining = math.abs(targetZ - lastKnown.z)
                    print(string.format("  Z progress: %d (GPS: %d, %d, %d) - %d blocks to go", moveCount, lastKnown.x, lastKnown.y, lastKnown.z, remaining))
                    
                    -- CRITICAL: Check if distance is INCREASING (moving wrong way!)
                    if remaining > lastDistance + 2 then
                        print("  ✗ ERROR: Moving AWAY from target!")
                        print(string.format("    Was %d blocks away, now %d blocks away", lastDistance, remaining))
                        print("    Direction is WRONG! Breaking out...")
                        break  -- Exit loop and recalculate
                    end
                    lastDistance = remaining
                    
                    -- Check if we need to change direction
                    if (oldPos.z < targetZ) ~= (lastKnown.z < targetZ) then
                        print("  ⚠ Correcting direction...")
                    end
                else
                    print(string.format("  Z progress: %d", moveCount))
                end
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(zDiff) > 0 and moveCount >= math.abs(zDiff) + 5 then
            print("  Z: Reached expected distance")
            break
        end
    end
    
    -- Final GPS check with correction
    print("Verifying final position with GPS...")
    local fx, fy, fz = gps.locate(5)
    if fx then
        lastKnown = {x=math.floor(fx), y=math.floor(fy), z=math.floor(fz)}
        local distance = math.abs(lastKnown.x - targetX) + math.abs(lastKnown.y - targetY) + math.abs(lastKnown.z - targetZ)
        
        if distance == 0 then
            print(string.format("✓ Arrived at: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            return true
        elseif distance <= 3 then
            print(string.format("✓ Close: %d, %d, %d (off by %d)", lastKnown.x, lastKnown.y, lastKnown.z, distance))
            
            -- Try to correct small offset (EXACT positioning required)
            print("  Fine-tuning to EXACT position...")
            
            -- Y axis first
            while lastKnown.y < targetY do
                print(string.format("  Moving up (Y: %d → %d)", lastKnown.y, targetY))
                if not tryUp() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.y > targetY do
                print(string.format("  Moving down (Y: %d → %d)", lastKnown.y, targetY))
                if not tryDown() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- X axis
            while lastKnown.x < targetX do
                -- Check for return home command
                checkCommandsNonBlocking()
                if returnHomeRequested then
                    print("⚠ Return home requested during fine-tuning")
                    return
                end
                
                print(string.format("  Moving East (X: %d → %d)", lastKnown.x, targetX))
                turnTo(1)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.x > targetX do
                -- Check for return home command
                checkCommandsNonBlocking()
                if returnHomeRequested then
                    print("⚠ Return home requested during fine-tuning")
                    return
                end
                
                print(string.format("  Moving West (X: %d → %d)", lastKnown.x, targetX))
                turnTo(3)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- Z axis
            while lastKnown.z < targetZ do
                -- Check for return home command
                checkCommandsNonBlocking()
                if returnHomeRequested then
                    print("⚠ Return home requested during fine-tuning")
                    return
                end
                
                print(string.format("  Moving South (Z: %d → %d)", lastKnown.z, targetZ))
                turnTo(2)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.z > targetZ do
                -- Check for return home command
                checkCommandsNonBlocking()
                if returnHomeRequested then
                    print("⚠ Return home requested during fine-tuning")
                    return
                end
                
                print(string.format("  Moving North (Z: %d → %d)", lastKnown.z, targetZ))
                turnTo(0)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- Final check
            fx, fy, fz = gps.locate(5)
            if fx then
                lastKnown = {x=math.floor(fx), y=math.floor(fy), z=math.floor(fz)}
                distance = math.abs(lastKnown.x - targetX) + math.abs(lastKnown.y - targetY) + math.abs(lastKnown.z - targetZ)
                if distance == 0 then
                    print(string.format("✓ EXACT position: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
                else
                    print(string.format("✓ Best effort: %d, %d, %d (off by %d)", lastKnown.x, lastKnown.y, lastKnown.z, distance))
                end
            end
            
            return true
        else
            print(string.format("⚠ Off by %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            print(string.format("  Target: %d, %d, %d", targetX, targetY, targetZ))
            print("  Attempting correction...")
            
            -- Try to move to exact position (with recursion limit)
            return moveAbs(targetX, targetY, targetZ, _depth + 1)  -- Recursive call
        end
    else
        print("⚠ GPS unavailable for final check")
        print("  Using dead reckoning position")
        print(string.format("  Estimated: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
        return true
    end
end

----------------------------------
-- PATH EXECUTION
----------------------------------
local function executePathSteps(steps)
    if not steps or #steps == 0 then
        return false
    end
    
    print(string.format("Executing path: %d steps", #steps))
    
    for i, step in ipairs(steps) do
        -- Check for return home command before each step
        checkCommandsNonBlocking()
        if returnHomeRequested then
            print("⚠ Return home requested, aborting path execution")
            return false
        end
        
        if i % 10 == 0 then
            print(string.format("  Step %d/%d", i, #steps))
        end
        moveAbs(step.x, step.y, step.z)
    end
    
    print("✓ Path complete")
    return true
end

----------------------------------
-- FUEL MANAGEMENT
----------------------------------
local function invRefuel(amountNeeded)
    local startFuel = turtle.getFuelLevel()
    local targetFuel = startFuel + (amountNeeded or 1000)
    
    for slot = 1, 16 do
        if turtle.getFuelLevel() >= targetFuel then
            break
        end
        
        turtle.select(slot)
        if turtle.refuel(0) then
            local itemCount = turtle.getItemCount(slot)
            for i = 1, itemCount do
                if turtle.getFuelLevel() >= targetFuel then
                    break
                end
                turtle.refuel(1)
            end
        end
    end
    turtle.select(1)
    
    local gained = turtle.getFuelLevel() - startFuel
    if gained > 0 then
        print(string.format("Refueled: +%d (now %d)", gained, turtle.getFuelLevel()))
    end
    return gained
end

local function smartRefuel()
    local current = turtle.getFuelLevel()
    local pos = getPos()
    
    local homeTrip = math.abs(homePos.x - pos.x) + 
                     math.abs(homePos.y - pos.y) + 
                     math.abs(homePos.z - pos.z)
    local buffer = 500
    local needed = homeTrip + buffer
    
    if current < needed then
        print(string.format("Low fuel: %d/%d", current, needed))
        invRefuel(needed - current + 200)
        return true
    end
    return false
end

----------------------------------
-- INVENTORY MANAGEMENT
----------------------------------
local KEEP_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod"
}

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function depositToChest()
    print("Depositing to chest...")
    
    -- Ensure we're at exact home position
    local px, py, pz = gps.locate(5)
    if px then
        local currentX, currentY, currentZ = math.floor(px), math.floor(py), math.floor(pz)
        print(string.format("  Current: %d, %d, %d", currentX, currentY, currentZ))
        print(string.format("  Home:    %d, %d, %d", homePos.x, homePos.y, homePos.z))
        
        if currentX ~= homePos.x or currentY ~= homePos.y or currentZ ~= homePos.z then
            print("  ⚠ Position mismatch! Correcting...")
            moveAbs(homePos.x, homePos.y, homePos.z)
        end
    end
    
    -- Find chest using turtle.inspect() in 4 directions
    print("  Scanning for chest...")
    
    local chestDir = nil
    local chestFound = false
    
    -- Scan all 4 horizontal directions
    for dir = 0, 3 do
        local success, data = turtle.inspect()
        if success and data.name and data.name:find("chest") then
            chestDir = dir
            chestFound = true
            print(string.format("  ✓ Found chest in direction %d (%s)", 
                dir, ({"North", "East", "South", "West"})[dir + 1]))
            break
        end
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    if not chestFound then
        print("  ✗ ERROR: No chest found!")
        print("  Keeping items in inventory...")
        rednet.send(COMPUTER_ID, {
            type = "status_update",
            status = "ERROR: No chest at home!",
            position = homePos
        }, PROTOCOL)
        return false
    end
    
    -- For simplicity, assume chest is adjacent (no offset needed)
    local cx = 0
    local cy = 0
    local cz = 0
    print(string.format("  ✓ Chest at offset: %+d, %+d, %+d", cx, cy, cz))
    
    -- Face the chest (already found it in scan above)
    turnTo(chestDir)
    
    -- Update homeFacing to face AWAY from chest
    homeFacing = (chestDir + 2) % 4
    saveHomeLocation()  -- Save corrected direction
    print(string.format("  Home facing: %d (away from chest)", homeFacing))
    
    -- Chest found, deposit items
    local deposited = 0
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item and not isFuelItem(item.name) then
            turtle.select(i)
            if turtle.drop() then
                deposited = deposited + 1
            end
        end
    end
    
    print(string.format("✓ Deposited %d items", deposited))
    
    -- Turn to face away from chest (home direction)
    turnTo(homeFacing)
    
    smartRefuel()
    return true
end

local function inventoryAlmostFull()
    local emptySlots = 0
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            emptySlots = emptySlots + 1
        end
    end
    return emptySlots <= 3
end

----------------------------------
-- COMMUNICATION WITH COMPUTER
----------------------------------
local function requestPath()
    local pos = getPos()
    print(string.format("Requesting path from %d,%d,%d", pos.x, pos.y, pos.z))
    
    rednet.send(COMPUTER_ID, {
        type = "request_path",
        x = pos.x,
        y = pos.y,
        z = pos.z,
        oreFilter = ORE_FILTER  -- Send ore filter to computer
    }, PROTOCOL)
    
    local id, msg = rednet.receive(PROTOCOL, 10)
    if id and msg and msg.type == "path" then
        stats.pathsReceived = stats.pathsReceived + 1
        
        -- Check if scanner has environment detector
        if msg.has_envdetector then
            print("  Scanner has Environment Detector")
        end
        
        if msg.steps and #msg.steps > 0 then
            print(string.format("✓ Path received: %d steps", #msg.steps))
            return msg.steps, msg.target
        else
            print("No ores available")
            return nil, nil
        end
    end
    
    print("No response from computer")
    return nil, nil
end

local function requestScan()
    local pos = getPos()
    print("Requesting scan...")
    
    rednet.send(COMPUTER_ID, {
        type = "request_scan",
        x = pos.x,
        y = pos.y,
        z = pos.z
    }, PROTOCOL)
    
    stats.scansRequested = stats.scansRequested + 1
end

local function reportOreMined(target)
    rednet.send(COMPUTER_ID, {
        type = "ore_mined",
        x = target.x,
        y = target.y,
        z = target.z
    }, PROTOCOL)
    
    print(string.format("✓ Reported ore mined at %d,%d,%d", target.x, target.y, target.z))
end

----------------------------------
-- MAIN MINING LOOP
----------------------------------
print("")
print("Starting mining operations...")
print("Press Ctrl+T to stop")
print("")
print("Testing connection to computer...")

-- Test connection first
rednet.send(COMPUTER_ID, {type = "ping"}, PROTOCOL)
local testId, testMsg = rednet.receive(PROTOCOL, 3)
if testId then
    print("✓ Connected to computer ID:", COMPUTER_ID)
else
    print("⚠ Cannot reach computer ID:", COMPUTER_ID)
    print("Scanner appears offline. Continuing anyway...")
    print("Note: Turtle will work in standalone mode")
    print("  - No ore coordination with scanner")
    print("  - Will mine randomly if no scanner")
    print("")
    print("To fix later:")
    print("  1. Start scanner computer")
    print("  2. Check COMPUTER_ID matches")
    print("  3. Restart turtle")
    print("")
    sleep(3)  -- Show message for 3 seconds
end

----------------------------------
-- AUTO-RETURN HOME (if saved home exists)
----------------------------------
if savedHome then
    print("Checking position...")
    
    -- Get position with GPS validation
    print("Getting GPS coordinates...")
    local x, y, z = gps.locate(5)
    
    if not x then
        print("═══════════════════════════════════")
        print("ERROR: GPS signal not available!")
        print("═══════════════════════════════════")
        print("Cannot determine current position")
        print("")
        print("Solutions:")
        print("  1. Set up GPS satellites")
        print("  2. Move turtle closer to GPS")
        print("  3. Manually move turtle to home:")
        print(string.format("     %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Press ENTER to skip position check...")
        read()
    else
        local currentPos = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
        lastKnown = currentPos
        
        print(string.format("✓ GPS Position: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
        
        local atHome = (currentPos.x == homePos.x and 
                       currentPos.y == homePos.y and 
                       currentPos.z == homePos.z)
        
        if not atHome then
            local distance = math.abs(currentPos.x - homePos.x) + 
                           math.abs(currentPos.y - homePos.y) + 
                           math.abs(currentPos.z - homePos.z)
            
            print(string.format("⚠ Not at home! Distance: %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
            print(string.format("  Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
            print("")
            print("AUTO-NAVIGATING back to home base...")
            print("(This may take a while)")
            print("")
            
            -- Auto-navigate to home
            moveAbs(homePos.x, homePos.y, homePos.z)
            
            print("✓ Arrived at home!")
            
            -- After navigation, direction might be wrong!
            -- Reset facing to unknown so chest check will find it
            print("Checking orientation...")
        else
            print("✓ Turtle at home position")
        end
    end
    
    -- Verify chest is accessible (always check all directions!)
    print("Verifying chest...")
    
    -- Try all 4 directions to find chest
    local chestFound = false
    local chestDirection = nil
    local dirNames = {[0]="North", [1]="East", [2]="South", [3]="West"}
    
    print("  Scanning all directions...")
    for dir = 0, 3 do
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name then
            print(string.format("  Direction %d (%s): %s", facing, dirNames[facing], blockData.name))
            if string.find(blockData.name, "chest") then
                chestFound = true
                chestDirection = facing
                print(string.format("✓ Chest found facing %s (direction %d)", dirNames[facing], facing))
                
                -- Turtle is currently FACING the chest
                -- We need to face AWAY from chest
                print("  Turning to face away from chest...")
                turtle.turnLeft()
                turtle.turnLeft()
                facing = (facing + 2) % 4
                
                -- This is the correct home facing
                homeFacing = facing
                
                print(string.format("✓ Now facing %s (away from chest)", dirNames[facing]))
                
                -- Save corrected facing
                saveHomeLocation(homePos, homeFacing)
                print("✓ Direction saved")
                break
            end
        else
            print(string.format("  Direction %d (%s): Nothing", facing, dirNames[facing]))
        end
        
        -- Try next direction
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    if not chestFound then
        print("")
        print("═══════════════════════════════════")
        print("ERROR: Chest not found at home!")
        print("═══════════════════════════════════")
        print("Checked all 4 directions")
        print(string.format("Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Please:")
        print("  1. Place chest next to turtle")
        print("  2. OR delete home_location.txt")
        print("  3. Then restart miner_v2")
        print("═══════════════════════════════════")
        error("Chest verification failed")
    end
    
    print("✓ Chest verified and direction corrected!")
    
    print("✓ Ready to mine!")
    print("")
end

-- Initial scan request
print("Requesting initial scan...")
requestScan()
sleep(2)

----------------------------------
-- POSITION UPDATE
----------------------------------
local lastPositionUpdate = 0

local function sendPositionUpdate()
    -- Send position update every 5 seconds
    local now = os.epoch("utc")
    if now - lastPositionUpdate < 5000 then return end
    
    lastPositionUpdate = now
    local pos = getPos()
    rednet.send(COMPUTER_ID, {
        type = "status_update",
        status = "mining",
        position = pos
    }, PROTOCOL)
end

----------------------------------
-- FULL COMMAND HANDLER (processes return home)
----------------------------------
local function checkCommands()
    -- Check for commands from computer (non-blocking)
    local senderId, message = rednet.receive(PROTOCOL, 0)
    if senderId and message then
        if message.type == "return_home" then
            returnHomeRequested = true
            print("")
            print("═══════════════════════════════════")
            print("*** RETURN HOME command received! ***")
            print("═══════════════════════════════════")
            
            -- Send acknowledgment
            rednet.send(COMPUTER_ID, {
                type = "status_update",
                status = "returning home",
                position = getPos()
            }, PROTOCOL)
            
            print("Returning to base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            
            -- Send arrived status
            rednet.send(COMPUTER_ID, {
                type = "status_update", 
                status = "at home",
                position = homePos
            }, PROTOCOL)
            
            print("✓ At home. Resuming in 5 seconds...")
            print("(Press Ctrl+T to stop)")
            print("═══════════════════════════════════")
            sleep(5)
            returnHomeRequested = false  -- Reset flag
            return true
        end
    end
    return false
end

local miningCycle = 0
local idleCount = 0

while true do
    -- Check for commands at start of cycle
    checkCommands()
    
    -- Send position update to scanner
    sendPositionUpdate()
    
    miningCycle = miningCycle + 1
    print(string.format("=== Cycle %d ===", miningCycle))
    
    -- Check inventory
    if inventoryAlmostFull() then
        print("Inventory full - returning home")
        moveAbs(homePos.x, homePos.y, homePos.z)
        depositToChest()
    end
    
    -- Check for commands after deposit
    checkCommands()
    
    -- Check fuel
    smartRefuel()
    
    -- Check for commands before requesting path
    checkCommands()
    
    -- Request path to next ore
    local steps, target = requestPath()
    
    if steps and target then
        idleCount = 0
        
        -- Execute path
        print(string.format("Target: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        local success = false
        local ok, err = pcall(function()
            success = executePathSteps(steps)
        end)
        
        if not ok then
            print("ERROR moving to ore:", err)
            print("Reporting ore as unreachable...")
            rednet.send(COMPUTER_ID, {
                type = "ore_failed",
                x = target.x,
                y = target.y,
                z = target.z,
                position = getPos()  -- Include current position
            }, PROTOCOL)
        elseif success then
            -- Check if we're actually at the ore location
            local pos = getPos()
            local dist = math.abs(pos.x - target.x) + math.abs(pos.y - target.y) + math.abs(pos.z - target.z)
            
            print(string.format("Distance to ore: %d blocks", dist))
            print(string.format("  Current: %d, %d, %d", pos.x, pos.y, pos.z))
            print(string.format("  Target:  %d, %d, %d", target.x, target.y, target.z))
            
            if dist <= 3 then
                -- Close enough - make final approach
                if dist > 0 then
                    print("Making final approach to ore...")
                    
                    -- Try to get closer (best effort)
                    local attempts = 0
                    while dist > 0 and attempts < 5 do
                        local moved = false
                        
                        -- Try Y axis first
                        if pos.y < target.y then
                            if tryUp() then moved = true end
                        elseif pos.y > target.y then
                            if tryDown() then moved = true end
                        end
                        
                        -- Try X axis
                        if pos.x < target.x then
                            turnTo(1)  -- East
                            if tryForward() then moved = true end
                        elseif pos.x > target.x then
                            turnTo(3)  -- West
                            if tryForward() then moved = true end
                        end
                        
                        -- Try Z axis
                        if pos.z < target.z then
                            turnTo(2)  -- South
                            if tryForward() then moved = true end
                        elseif pos.z > target.z then
                            turnTo(0)  -- North
                            if tryForward() then moved = true end
                        end
                        
                        -- Update position
                        pos = getPos()
                        local newDist = math.abs(pos.x - target.x) + math.abs(pos.y - target.y) + math.abs(pos.z - target.z)
                        
                        if newDist >= dist and not moved then
                            -- Not getting closer, stop trying
                            break
                        end
                        
                        dist = newDist
                        attempts = attempts + 1
                    end
                    
                    print(string.format("Final distance: %d blocks", dist))
                end
                
                -- Mine in all directions around turtle
                print("Mining ore (checking all directions)...")
                local oreFound = false
                
                -- Check and mine in front (all 4 directions)
                for dir = 0, 3 do
                    turnTo(dir)
                    local ok, blockData = turtle.inspect()
                    if ok and blockData.name and blockData.name:find("_ore") then
                        print(string.format("  ✓ Found ore in direction %d: %s", dir, blockData.name))
                        turtle.dig()
                        oreFound = true
                    end
                end
                
                -- Check and mine up
                local ok, blockData = turtle.inspectUp()
                if ok and blockData.name and blockData.name:find("_ore") then
                    print("  ✓ Found ore above: " .. blockData.name)
                    turtle.digUp()
                    oreFound = true
                end
                
                -- Check and mine down
                ok, blockData = turtle.inspectDown()
                if ok and blockData.name and blockData.name:find("_ore") then
                    print("  ✓ Found ore below: " .. blockData.name)
                    turtle.digDown()
                    oreFound = true
                end
                
                if oreFound then
                    print("✓ Ore mined successfully!")
                    stats.oresMined = stats.oresMined + 1
                    
                    -- Report to computer
                    reportOreMined(target)
                    
                    sleep(0.5)
                else
                    print("⚠ No ore found in any direction")
                    print("Ore may have been mined already or location inaccurate")
                    rednet.send(COMPUTER_ID, {
                        type = "ore_failed",
                        x = target.x,
                        y = target.y,
                        z = target.z,
                        position = pos
                    }, PROTOCOL)
                end
            else
                print(string.format("Too far from ore (distance: %d blocks)", dist))
                print("Reporting as unreachable...")
                rednet.send(COMPUTER_ID, {
                    type = "ore_failed",
                    x = target.x,
                    y = target.y,
                    z = target.z,
                    position = pos  -- Include current position
                }, PROTOCOL)
            end
        end
        
        -- Check for commands after mining
        checkCommands()
    else
        -- No ores available
        idleCount = idleCount + 1
        print(string.format("Idle (no ores) - count: %d", idleCount))
        
        -- Check for commands during idle
        checkCommands()
        
        if idleCount >= 3 then
            print("Requesting new scan...")
            requestScan()
            idleCount = 0
        end
        
        -- Emergency: If scanner not responding, return home
        if idleCount >= 6 then
            print("WARNING: Scanner not responding!")
            print("Returning to home base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            print("At home. Waiting for scanner...")
            sleep(30)
            idleCount = 0
        end
        
        sleep(5)
    end
    
    -- Periodic refuel and smart checks
    smartRefuel()
end

----------------------------------
-- CLEANUP (unreachable but good practice)
----------------------------------
print("")
print("Returning home...")
moveAbs(homePos.x, homePos.y, homePos.z)
depositToChest()

print("")
print("═══════════════════════════════════")
print("  MINING COMPLETE")
print("═══════════════════════════════════")
print(string.format("Ores mined: %d", stats.oresMined))
print(string.format("Total moves: %d", stats.totalMoves))
print(string.format("Free moves: %d (%.1f%%)", 
    stats.freeMoves, (stats.freeMoves / math.max(1, stats.totalMoves) * 100)))
print("")
print(string.format("Blocks mined: %d", 
    stats.blocksMinedForward + stats.blocksMinedUp + stats.blocksMinedDown))
print(string.format("  Forward: %d", stats.blocksMinedForward))
print(string.format("  Up: %d", stats.blocksMinedUp))
print(string.format("  Down: %d", stats.blocksMinedDown))
print("")
print(string.format("Paths received: %d", stats.pathsReceived))
print(string.format("Scans requested: %d", stats.scansRequested))
print("═══════════════════════════════════")
