-- SmartMiner Turtle V2 - A* Pathfinding Client
-- Works with computer brain for coordinated mining

----------------------------------
-- CONFIGURATION
----------------------------------
local COMPUTER_ID = 1                -- ID of the computer brain
local PROTOCOL = "smartminer"        -- Must match computer
local TURTLE_ID = os.getComputerID and os.getComputerID() or 2

-- ORE FILTER: Which ores to mine (set to nil to mine ALL ores)
local ORE_FILTER = {
    "iron",      -- Mine iron ore
    "coal",      -- Mine coal ore
    "gold",      -- Mine gold ore
    "diamond",   -- Mine diamond ore
    -- "copper",    -- Uncomment to mine copper
    -- "redstone",  -- Uncomment to mine redstone
    -- "lapis",     -- Uncomment to mine lapis
    -- "emerald",   -- Uncomment to mine emerald
}
-- Set to nil to mine ALL ore types: local ORE_FILTER = nil

----------------------------------
-- MOVEMENT STATISTICS
----------------------------------
local stats = {
    blocksMinedForward = 0,
    blocksMinedUp = 0,
    blocksMinedDown = 0,
    freeMoves = 0,
    totalMoves = 0,
    oresMined = 0,
    pathsReceived = 0,
    scansRequested = 0,
}

----------------------------------
-- MODEM AUTO-DETECTION
----------------------------------
local function findAndOpenModem()
    -- Try to find wireless modem on any side
    for _, side in ipairs({"right", "left", "top", "bottom", "front", "back"}) do
        if peripheral.getType(side) and peripheral.getType(side):find("modem") then
            local m = peripheral.wrap(side)
            if m.isWireless and m.isWireless() then
                rednet.open(side)
                print("Modem found on:", side)
                return true
            end
        end
    end
    return false
end

if not findAndOpenModem() then
    error("ERROR: No wireless modem found!")
end

----------------------------------
-- GPS AND POSITION TRACKING
----------------------------------
local gps = gps  -- Use built-in GPS
local lastKnown = {x=0, y=0, z=0}
local facing = 0  -- 0=north, 1=east, 2=south, 3=west

local function getPos()
    if gps then
        local x, y, z = gps.locate(2)
        if x then 
            lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
            return lastKnown
        end
    end
    -- Fallback to internal tracking
    return lastKnown
end

----------------------------------
-- PERSISTENT STORAGE
----------------------------------
local HOME_FILE = "home_location.txt"

local function saveHomeLocation(pos, face)
    local f = fs.open(HOME_FILE, "w")
    if f then
        f.writeLine(textutils.serialize({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            facing = face
        }))
        f.close()
        print("✓ Home location saved")
        return true
    end
    return false
end

local function loadHomeLocation()
    if fs.exists(HOME_FILE) then
        local f = fs.open(HOME_FILE, "r")
        if f then
            local data = f.readAll()
            f.close()
            local ok, result = pcall(function() return textutils.unserialize(data) end)
            if ok and result then
                print("✓ Found saved home location")
                return result
            end
        end
    end
    return nil
end

----------------------------------
-- BASE STATION CHEST SETUP
----------------------------------
print("═══════════════════════════════════")
print("  SMARTMINER TURTLE V2")
print("═══════════════════════════════════")
print("Turtle ID:", TURTLE_ID)
print("Computer ID:", COMPUTER_ID)
print("")

local homePos
local homeFacing

-- Try to load saved home location
local savedHome = loadHomeLocation()

if savedHome then
    print(string.format("Saved home: %d, %d, %d", savedHome.x, savedHome.y, savedHome.z))
    print("Use saved location? (Y/n)")
    local input = read()
    
    if input ~= "n" and input ~= "N" then
        homePos = {x=savedHome.x, y=savedHome.y, z=savedHome.z}
        homeFacing = savedHome.facing
        facing = homeFacing
        print("✓ Using saved home location")
    end
end

-- If no saved location or user declined, set up new one
if not homePos then
    print("Place chest BEHIND turtle")
    print("(Turtle should face AWAY from chest)")
    print("")
    print("Press ENTER when ready...")
    read()

    -- Save home position
    print("Getting home position...")
    homePos = getPos()
    print(string.format("✓ Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))

    -- Verify chest
    print("Verifying chest...")
    turtle.turnLeft()
    turtle.turnLeft()

    local ok, chestData = turtle.inspect()
    if not ok or not string.find(chestData.name or "", "chest") then
        turtle.turnLeft()
        turtle.turnLeft()
        error("ERROR: No chest found behind turtle!")
    end

    print("✓ Chest detected!")
    turtle.turnLeft()
    turtle.turnLeft()
end

----------------------------------
-- DETECT FACING DIRECTION
----------------------------------
local function detectFacing()
    local x1, y1, z1 = getPos().x, getPos().y, getPos().z
    
    -- Try to move forward
    local moved = false
    for attempt = 1, 5 do
        if turtle.forward() then
            moved = true
            break
        end
        turtle.dig()
        turtle.attack()
        sleep(0.3)
    end
    
    if not moved then
        print("WARNING: Cannot detect facing (blocked)")
        return 0  -- Default to north
    end
    
    local x2, y2, z2 = getPos().x, getPos().y, getPos().z
    local dx, dz = x2 - x1, z2 - z1
    
    turtle.back()  -- Return to start
    
    if dz == -1 then return 0 end     -- North
    if dx == 1 then return 1 end      -- East
    if dz == 1 then return 2 end      -- South
    if dx == -1 then return 3 end     -- West
    return 0  -- Default
end

-- Only detect facing if not already set
if not homeFacing then
    facing = detectFacing()
    homeFacing = facing
    -- Save the home location with facing
    saveHomeLocation(homePos, homeFacing)
end

local dirNames = {[0]="north", [1]="east", [2]="south", [3]="west"}
print(string.format("✓ Facing: %s", dirNames[facing]))
print(string.format("✓ Home: %d,%d,%d (Saved)", homePos.x, homePos.y, homePos.z))
print("✓ Setup complete")
print("═══════════════════════════════════")

----------------------------------
-- SMART MOVEMENT FUNCTIONS
----------------------------------
local function tryForward()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.forward() then
        stats.freeMoves = stats.freeMoves + 1
        -- Update internal position if no GPS
        if not gps then
            if facing == 0 then lastKnown.z = lastKnown.z - 1
            elseif facing == 1 then lastKnown.x = lastKnown.x + 1
            elseif facing == 2 then lastKnown.z = lastKnown.z + 1
            elseif facing == 3 then lastKnown.x = lastKnown.x - 1
            end
        end
        return true
    end
    
    -- Blocked - dig and retry
    while not turtle.forward() do
        if turtle.dig() then
            stats.blocksMinedForward = stats.blocksMinedForward + 1
        end
        turtle.attack()
        sleep(0.1)
    end
    
    -- Update position after successful move
    if not gps then
        if facing == 0 then lastKnown.z = lastKnown.z - 1
        elseif facing == 1 then lastKnown.x = lastKnown.x + 1
        elseif facing == 2 then lastKnown.z = lastKnown.z + 1
        elseif facing == 3 then lastKnown.x = lastKnown.x - 1
        end
    end
    return true
end

local function tryUp()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.up() then
        stats.freeMoves = stats.freeMoves + 1
        if not gps then lastKnown.y = lastKnown.y + 1 end
        return true
    end
    
    while not turtle.up() do
        if turtle.digUp() then
            stats.blocksMinedUp = stats.blocksMinedUp + 1
        end
        turtle.attackUp()
        sleep(0.1)
    end
    
    if not gps then lastKnown.y = lastKnown.y + 1 end
    return true
end

local function tryDown()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.down() then
        stats.freeMoves = stats.freeMoves + 1
        if not gps then lastKnown.y = lastKnown.y - 1 end
        return true
    end
    
    while not turtle.down() do
        if turtle.digDown() then
            stats.blocksMinedDown = stats.blocksMinedDown + 1
        end
        turtle.attackDown()
        sleep(0.1)
    end
    
    if not gps then lastKnown.y = lastKnown.y - 1 end
    return true
end

----------------------------------
-- DIRECTION CONTROL
----------------------------------
local function turnTo(targetDir)
    while facing ~= targetDir do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
end

----------------------------------
-- ABSOLUTE POSITION MOVEMENT
----------------------------------
local function moveAbs(targetX, targetY, targetZ)
    local pos = getPos()
    local moveCount = 0
    local maxMoves = 500
    
    -- Move vertically first
    while pos.y < targetY and moveCount < maxMoves do
        tryUp()
        pos = getPos()
        moveCount = moveCount + 1
    end
    
    moveCount = 0
    while pos.y > targetY and moveCount < maxMoves do
        tryDown()
        pos = getPos()
        moveCount = moveCount + 1
    end
    
    -- Move on X axis
    if pos.x < targetX then turnTo(1) end  -- East
    if pos.x > targetX then turnTo(3) end  -- West
    
    moveCount = 0
    while pos.x ~= targetX and moveCount < maxMoves do
        tryForward()
        pos = getPos()
        moveCount = moveCount + 1
    end
    
    -- Move on Z axis
    if pos.z < targetZ then turnTo(2) end  -- South
    if pos.z > targetZ then turnTo(0) end  -- North
    
    moveCount = 0
    while pos.z ~= targetZ and moveCount < maxMoves do
        tryForward()
        pos = getPos()
        moveCount = moveCount + 1
    end
    
    return true
end

----------------------------------
-- PATH EXECUTION
----------------------------------
local function executePathSteps(steps)
    if not steps or #steps == 0 then
        return false
    end
    
    print(string.format("Executing path: %d steps", #steps))
    
    for i, step in ipairs(steps) do
        if i % 10 == 0 then
            print(string.format("  Step %d/%d", i, #steps))
        end
        moveAbs(step.x, step.y, step.z)
    end
    
    print("✓ Path complete")
    return true
end

----------------------------------
-- FUEL MANAGEMENT
----------------------------------
local function invRefuel(amountNeeded)
    local startFuel = turtle.getFuelLevel()
    local targetFuel = startFuel + (amountNeeded or 1000)
    
    for slot = 1, 16 do
        if turtle.getFuelLevel() >= targetFuel then
            break
        end
        
        turtle.select(slot)
        if turtle.refuel(0) then
            local itemCount = turtle.getItemCount(slot)
            for i = 1, itemCount do
                if turtle.getFuelLevel() >= targetFuel then
                    break
                end
                turtle.refuel(1)
            end
        end
    end
    turtle.select(1)
    
    local gained = turtle.getFuelLevel() - startFuel
    if gained > 0 then
        print(string.format("Refueled: +%d (now %d)", gained, turtle.getFuelLevel()))
    end
    return gained
end

local function smartRefuel()
    local current = turtle.getFuelLevel()
    local pos = getPos()
    
    local homeTrip = math.abs(homePos.x - pos.x) + 
                     math.abs(homePos.y - pos.y) + 
                     math.abs(homePos.z - pos.z)
    local buffer = 500
    local needed = homeTrip + buffer
    
    if current < needed then
        print(string.format("Low fuel: %d/%d", current, needed))
        invRefuel(needed - current + 200)
        return true
    end
    return false
end

----------------------------------
-- INVENTORY MANAGEMENT
----------------------------------
local KEEP_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod"
}

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function depositToChest()
    print("Depositing to chest...")
    
    -- Turn to face home direction
    while facing ~= homeFacing do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    -- Turn around to face chest
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    local deposited = 0
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item and not isFuelItem(item.name) then
            turtle.select(i)
            if turtle.drop() then
                deposited = deposited + 1
            end
        end
    end
    
    -- Turn back
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    smartRefuel()
    print(string.format("✓ Deposited %d stacks", deposited))
    return deposited
end

local function inventoryAlmostFull()
    local emptySlots = 0
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            emptySlots = emptySlots + 1
        end
    end
    return emptySlots <= 3
end

----------------------------------
-- COMMUNICATION WITH COMPUTER
----------------------------------
local function requestPath()
    local pos = getPos()
    print(string.format("Requesting path from %d,%d,%d", pos.x, pos.y, pos.z))
    
    rednet.send(COMPUTER_ID, {
        type = "request_path",
        x = pos.x,
        y = pos.y,
        z = pos.z,
        oreFilter = ORE_FILTER  -- Send ore filter to computer
    }, PROTOCOL)
    
    local id, msg = rednet.receive(PROTOCOL, 10)
    if id and msg and msg.type == "path" then
        stats.pathsReceived = stats.pathsReceived + 1
        if msg.steps and #msg.steps > 0 then
            print(string.format("✓ Path received: %d steps", #msg.steps))
            return msg.steps, msg.target
        else
            print("No ores available")
            return nil, nil
        end
    end
    
    print("No response from computer")
    return nil, nil
end

local function requestScan()
    local pos = getPos()
    print("Requesting scan...")
    
    rednet.send(COMPUTER_ID, {
        type = "request_scan",
        x = pos.x,
        y = pos.y,
        z = pos.z
    }, PROTOCOL)
    
    stats.scansRequested = stats.scansRequested + 1
end

local function reportOreMined(target)
    rednet.send(COMPUTER_ID, {
        type = "ore_mined",
        x = target.x,
        y = target.y,
        z = target.z
    }, PROTOCOL)
    
    print(string.format("✓ Reported ore mined at %d,%d,%d", target.x, target.y, target.z))
end

----------------------------------
-- MAIN MINING LOOP
----------------------------------
print("")
print("Starting mining operations...")
print("Press Ctrl+T to stop")
print("")
print("Testing connection to computer...")

-- Test connection first
rednet.send(COMPUTER_ID, {type = "ping"}, PROTOCOL)
local testId, testMsg = rednet.receive(PROTOCOL, 3)
if testId then
    print("✓ Connected to computer ID:", COMPUTER_ID)
else
    print("✗ Cannot reach computer ID:", COMPUTER_ID)
    print("Make sure:")
    print("  1. Scanner is running")
    print("  2. Both have wireless modems")
    print("  3. COMPUTER_ID is correct")
    print("")
    print("Press ENTER to continue anyway...")
    read()
end

-- Initial scan request
print("Requesting initial scan...")
requestScan()
sleep(2)

local miningCycle = 0
local idleCount = 0

while true do
    miningCycle = miningCycle + 1
    print(string.format("=== Cycle %d ===", miningCycle))
    
    -- Check inventory
    if inventoryAlmostFull() then
        print("Inventory full - returning home")
        moveAbs(homePos.x, homePos.y, homePos.z)
        depositToChest()
    end
    
    -- Check fuel
    smartRefuel()
    
    -- Request path to next ore
    local steps, target = requestPath()
    
    if steps and target then
        idleCount = 0
        
        -- Execute path
        print(string.format("Target: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        local success = false
        local ok, err = pcall(function()
            success = executePathSteps(steps)
        end)
        
        if not ok then
            print("ERROR moving to ore:", err)
            print("Reporting ore as unreachable...")
            rednet.send(COMPUTER_ID, {
                type = "ore_failed",
                x = target.x,
                y = target.y,
                z = target.z
            }, PROTOCOL)
        elseif success then
            -- Check if we're actually at the ore location
            local pos = getPos()
            local dist = math.abs(pos.x - target.x) + math.abs(pos.y - target.y) + math.abs(pos.z - target.z)
            
            if dist <= 1 then
                -- We're close enough, mine it
                print("Mining ore...")
                turtle.dig()
                turtle.digDown()
                turtle.digUp()
                stats.oresMined = stats.oresMined + 1
                
                -- Report to computer
                reportOreMined(target)
                
                sleep(0.5)
            else
                print(string.format("Not close enough to ore (distance: %d)", dist))
                print("Reporting as unreachable...")
                rednet.send(COMPUTER_ID, {
                    type = "ore_failed",
                    x = target.x,
                    y = target.y,
                    z = target.z
                }, PROTOCOL)
            end
        end
    else
        -- No ores available
        idleCount = idleCount + 1
        print(string.format("Idle (no ores) - count: %d", idleCount))
        
        if idleCount >= 3 then
            print("Requesting new scan...")
            requestScan()
            idleCount = 0
        end
        
        -- Emergency: If scanner not responding, return home
        if idleCount >= 6 then
            print("WARNING: Scanner not responding!")
            print("Returning to home base...")
            moveTo(homePos.x, homePos.y, homePos.z)
            depositToChest()
            print("At home. Waiting for scanner...")
            sleep(30)
            idleCount = 0
        end
        
        sleep(5)
    end
    
    -- Periodic refuel and smart checks
    smartRefuel()
end

----------------------------------
-- CLEANUP (unreachable but good practice)
----------------------------------
print("")
print("Returning home...")
moveAbs(homePos.x, homePos.y, homePos.z)
depositToChest()

print("")
print("═══════════════════════════════════")
print("  MINING COMPLETE")
print("═══════════════════════════════════")
print(string.format("Ores mined: %d", stats.oresMined))
print(string.format("Total moves: %d", stats.totalMoves))
print(string.format("Free moves: %d (%.1f%%)", 
    stats.freeMoves, (stats.freeMoves / math.max(1, stats.totalMoves) * 100)))
print("")
print(string.format("Blocks mined: %d", 
    stats.blocksMinedForward + stats.blocksMinedUp + stats.blocksMinedDown))
print(string.format("  Forward: %d", stats.blocksMinedForward))
print(string.format("  Up: %d", stats.blocksMinedUp))
print(string.format("  Down: %d", stats.blocksMinedDown))
print("")
print(string.format("Paths received: %d", stats.pathsReceived))
print(string.format("Scans requested: %d", stats.scansRequested))
print("═══════════════════════════════════")
