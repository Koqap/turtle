-- SmartMiner Turtle V2 - A* Pathfinding Client
-- Works with computer brain for coordinated mining

----------------------------------
-- CONFIGURATION
----------------------------------
local COMPUTER_ID = 3                -- ID of the computer brain
local PROTOCOL = "smartminer"        -- Must match computer
local TURTLE_ID = os.getComputerID and os.getComputerID() or 2

-- ORE FILTER: Which ores to mine (set to nil to mine ALL ores)
local ORE_FILTER = {
    "iron",      -- Mine iron ore
    "coal",      -- Mine coal ore
    "gold",      -- Mine gold ore
    "diamond",   -- Mine diamond ore
    -- "copper",    -- Uncomment to mine copper
    -- "redstone",  -- Uncomment to mine redstone
    -- "lapis",     -- Uncomment to mine lapis
    -- "emerald",   -- Uncomment to mine emerald
}
-- Set to nil to mine ALL ore types: local ORE_FILTER = nil

----------------------------------
-- MOVEMENT STATISTICS
----------------------------------
local stats = {
    blocksMinedForward = 0,
    blocksMinedUp = 0,
    blocksMinedDown = 0,
    freeMoves = 0,
    totalMoves = 0,
    oresMined = 0,
    pathsReceived = 0,
    scansRequested = 0,
}

----------------------------------
-- MODEM AUTO-DETECTION
----------------------------------
local function findAndOpenModem()
    -- Try to find wireless modem on any side
    for _, side in ipairs({"right", "left", "top", "bottom", "front", "back"}) do
        if peripheral.getType(side) and peripheral.getType(side):find("modem") then
            local m = peripheral.wrap(side)
            if m.isWireless and m.isWireless() then
                rednet.open(side)
                print("Modem found on:", side)
                return true
            end
        end
    end
    return false
end

if not findAndOpenModem() then
    error("ERROR: No wireless modem found!")
end

----------------------------------
-- GPS AND POSITION TRACKING
----------------------------------
local gps = gps  -- Use built-in GPS
local lastKnown = {x=0, y=0, z=0}
local facing = 0  -- 0=north, 1=east, 2=south, 3=west

-- Home position and facing (declared early for saveHomeLocation)
local homePos
local homeFacing

local function getPos()
    -- Try GPS multiple times
    for attempt = 1, 3 do
        local x, y, z = gps.locate(5)
        if x then 
            lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
            return lastKnown
        end
        if attempt < 3 then
            sleep(1)
        end
    end
    -- Fallback to internal tracking (may be inaccurate!)
    return lastKnown
end

----------------------------------
-- PERSISTENT STORAGE
----------------------------------
local HOME_FILE = "home_location.txt"

local function saveHomeLocation(pos, face)
    -- Use global variables if parameters not provided
    pos = pos or homePos
    face = face or homeFacing
    
    if not pos then
        print("✗ Cannot save: No home position")
        return false
    end
    
    local f = fs.open(HOME_FILE, "w")
    if f then
        f.writeLine(textutils.serialize({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            facing = face
        }))
        f.close()
        print("✓ Home location saved")
        return true
    end
    return false
end

local function loadHomeLocation()
    if fs.exists(HOME_FILE) then
        local f = fs.open(HOME_FILE, "r")
        if f then
            local data = f.readAll()
            f.close()
            local ok, result = pcall(function() return textutils.unserialize(data) end)
            if ok and result then
                print("✓ Found saved home location")
                return result
            end
        end
    end
    return nil
end

----------------------------------
-- ENVIRONMENT DETECTOR (Advanced Peripherals)
----------------------------------
local envDetector = peripheral.find("environmentDetector")

local function scanBlocksWithEnvDetector(radius)
    if not envDetector then return nil end
    
    print("Using Environment Detector for advanced scan...")
    local ok, blocks = pcall(function() 
        return envDetector.scan(radius) 
    end)
    
    if ok and blocks then
        print(string.format("  Scanned %d blocks in %d block radius", #blocks, radius))
        return blocks
    end
    return nil
end

local function findChestWithEnvDetector()
    if not envDetector then return nil end
    
    print("Scanning for chests with Environment Detector...")
    
    -- Scan 5 block radius
    local blocks = scanBlocksWithEnvDetector(5)
    if not blocks then return nil end
    
    -- Find chests
    local chests = {}
    for _, block in ipairs(blocks) do
        if block.name and string.find(block.name, "chest") then
            table.insert(chests, block)
            print(string.format("  Found chest at offset: %d, %d, %d", 
                block.x or 0, block.y or 0, block.z or 0))
        end
    end
    
    if #chests == 0 then
        print("  No chests found in scan")
        return nil
    end
    
    -- Find closest chest
    local closest = chests[1]
    local minDist = math.abs(closest.x or 0) + math.abs(closest.y or 0) + math.abs(closest.z or 0)
    
    for _, chest in ipairs(chests) do
        local dist = math.abs(chest.x or 0) + math.abs(chest.y or 0) + math.abs(chest.z or 0)
        if dist < minDist then
            closest = chest
            minDist = dist
        end
    end
    
    return closest
end

local function detectChestEnvironment()
    print("═══════════════════════════════")
    print("  ENVIRONMENT AUTO-DETECTION")
    print("═══════════════════════════════")
    print("")
    
    -- Get current position
    local pos = getPos()
    print(string.format("Current position: %d, %d, %d", pos.x, pos.y, pos.z))
    
    -- Try Environment Detector first (if available)
    if envDetector then
        print("✓ Environment Detector found!")
        local chest = findChestWithEnvDetector()
        
        if chest and chest.x and chest.z then
            local cx, cy, cz = chest.x, chest.y or 0, chest.z
            print(string.format("✓ Chest detected at offset: %+d, %+d, %+d", cx, cy, cz))
            
            -- Determine direction based on offset
            local chestDir = nil
            if math.abs(cx) > math.abs(cz) then
                -- X axis dominant
                if cx > 0 then
                    chestDir = 1  -- East
                    print("  Chest is to the EAST")
                else
                    chestDir = 3  -- West
                    print("  Chest is to the WEST")
                end
            else
                -- Z axis dominant
                if cz > 0 then
                    chestDir = 2  -- South
                    print("  Chest is to the SOUTH")
                else
                    chestDir = 0  -- North
                    print("  Chest is to the NORTH")
                end
            end
            
            if cy ~= 0 then
                if cy > 0 then
                    print(string.format("  ⚠ Chest is %d block(s) ABOVE!", cy))
                else
                    print(string.format("  ⚠ Chest is %d block(s) BELOW!", math.abs(cy)))
                end
            end
            
            -- Face away from chest
            local awayDir = (chestDir + 2) % 4
            
            -- Turn to face away
            while facing ~= awayDir do
                turtle.turnRight()
                facing = (facing + 1) % 4
            end
            
            print(string.format("✓ Facing away from chest (direction %d)", awayDir))
            print(string.format("✓ Auto-configured home: %d, %d, %d", pos.x, pos.y, pos.z))
            
            return {
                x = pos.x,
                y = pos.y,
                z = pos.z,
                facing = awayDir
            }
        else
            print("  Environment Detector: No chest found nearby")
            print("  Falling back to turtle inspection...")
        end
    else
        print("Environment Detector not found (optional)")
        print("Using turtle inspection method...")
    end
    
    -- Fallback: Standard turtle inspection
    print("Scanning for chest with turtle...")
    
    -- Check all 4 horizontal directions for chest
    local chestDir = nil
    for dir = 0, 3 do
        local ok, blockData = turtle.inspect()
        if ok and blockData.name and string.find(blockData.name, "chest") then
            chestDir = dir
            print(string.format("✓ Found chest at direction %d!", dir))
            break
        end
        turtle.turnRight()
    end
    
    if chestDir then
        -- Face away from chest
        turtle.turnRight()
        turtle.turnRight()
        local awayDir = (chestDir + 2) % 4
        
        print(string.format("✓ Chest detected! Facing away (direction %d)", awayDir))
        print(string.format("✓ Auto-configured home: %d, %d, %d", pos.x, pos.y, pos.z))
        
        return {
            x = pos.x,
            y = pos.y,
            z = pos.z,
            facing = awayDir
        }
    end
    
    -- Check up and down
    local ok, blockData = turtle.inspectUp()
    if ok and blockData.name and string.find(blockData.name, "chest") then
        print("⚠ Chest is ABOVE! Move turtle down 1 block")
        return nil
    end
    
    ok, blockData = turtle.inspectDown()
    if ok and blockData.name and string.find(blockData.name, "chest") then
        print("⚠ Chest is BELOW! Move turtle up 1 block")
        return nil
    end
    
    print("✗ No chest found in any direction!")
    print("Please place chest next to turtle and retry")
    return nil
end

----------------------------------
-- BASE STATION CHEST SETUP
----------------------------------
print("═══════════════════════════════════")
print("  SMARTMINER TURTLE V2")
print("═══════════════════════════════════")
print("Turtle ID:", TURTLE_ID)
print("Computer ID:", COMPUTER_ID)
print("")

-- Try to load saved home location
local savedHome = loadHomeLocation()

if savedHome then
    -- Auto-load saved location without prompting
    homePos = {x=savedHome.x, y=savedHome.y, z=savedHome.z}
    homeFacing = savedHome.facing
    facing = homeFacing
    print(string.format("✓ Loaded home: %d, %d, %d", savedHome.x, savedHome.y, savedHome.z))
    print(string.format("✓ Facing: %s", ({"north","east","south","west"})[homeFacing+1] or "unknown"))
    print("(Position check will happen after loading functions...)")
    print("")
else
    -- First time setup with auto-detection
    print("FIRST TIME SETUP")
    print("")
    
    -- Try auto-detection first
    local detected = detectChestEnvironment()
    
    if detected then
        homePos = {x=detected.x, y=detected.y, z=detected.z}
        homeFacing = detected.facing
        facing = homeFacing
        
        -- Save immediately
        saveHomeLocation()
        print("")
        print("✓ Environment auto-configured and saved!")
        print("")
    else
        -- Fallback to manual setup
        print("")
        print("MANUAL SETUP")
        print("Place chest BEHIND turtle")
        print("(Turtle should face AWAY from chest)")
        print("")
        print("Press ENTER when ready...")
        read()

        -- Save home position
        print("Getting home position...")
        homePos = getPos()
        print(string.format("✓ Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))

        -- Verify chest
        print("Verifying chest...")
        turtle.turnLeft()
        turtle.turnLeft()

        local ok, chestData = turtle.inspect()
        if not ok or not string.find(chestData.name or "", "chest") then
            turtle.turnLeft()
            turtle.turnLeft()
            error("ERROR: No chest found behind turtle!")
        end

        print("✓ Chest detected!")
        turtle.turnLeft()
        turtle.turnLeft()
    end
end

----------------------------------
-- DETECT FACING DIRECTION
----------------------------------
local function detectFacing()
    local x1, y1, z1 = getPos().x, getPos().y, getPos().z
    
    -- Try to move forward
    local moved = false
    for attempt = 1, 5 do
        if turtle.forward() then
            moved = true
            break
        end
        turtle.dig()
        turtle.attack()
        sleep(0.3)
    end
    
    if not moved then
        print("WARNING: Cannot detect facing (blocked)")
        return 0  -- Default to north
    end
    
    local x2, y2, z2 = getPos().x, getPos().y, getPos().z
    local dx, dz = x2 - x1, z2 - z1
    
    turtle.back()  -- Return to start
    
    if dz == -1 then return 0 end     -- North
    if dx == 1 then return 1 end      -- East
    if dz == 1 then return 2 end      -- South
    if dx == -1 then return 3 end     -- West
    return 0  -- Default
end

-- Only detect facing if first-time setup (no saved home)
if not homeFacing then
    print("Detecting facing direction...")
    facing = detectFacing()
    homeFacing = facing
    
    local dirNames = {[0]="north", [1]="east", [2]="south", [3]="west"}
    print(string.format("✓ Facing: %s", dirNames[facing]))
    
    -- Save the home location with facing
    saveHomeLocation(homePos, homeFacing)
    print(string.format("✓ Home saved: %d,%d,%d", homePos.x, homePos.y, homePos.z))
end

print("✓ Setup complete")
print("═══════════════════════════════════")

----------------------------------
-- SMART MOVEMENT FUNCTIONS
----------------------------------
local function tryForward()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.forward() then
        stats.freeMoves = stats.freeMoves + 1
        -- ALWAYS update internal position for dead reckoning
        if facing == 0 then lastKnown.z = lastKnown.z - 1
        elseif facing == 1 then lastKnown.x = lastKnown.x + 1
        elseif facing == 2 then lastKnown.z = lastKnown.z + 1
        elseif facing == 3 then lastKnown.x = lastKnown.x - 1
        end
        return true
    end
    
    -- Blocked - dig and retry
    while not turtle.forward() do
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.dig() then
            stats.blocksMinedForward = stats.blocksMinedForward + 1
        end
        turtle.attack()
        sleep(0.1)
    end
    
    -- ALWAYS update position after successful move
    if facing == 0 then lastKnown.z = lastKnown.z - 1
    elseif facing == 1 then lastKnown.x = lastKnown.x + 1
    elseif facing == 2 then lastKnown.z = lastKnown.z + 1
    elseif facing == 3 then lastKnown.x = lastKnown.x - 1
    end
    return true
end

local function tryUp()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.up() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y + 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.up() do
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspectUp()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected above! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.digUp() then
            stats.blocksMinedUp = stats.blocksMinedUp + 1
        end
        turtle.attackUp()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y + 1  -- Always update
    return true
end

local function tryDown()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.down() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y - 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.down() do
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspectDown()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected below! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.digDown() then
            stats.blocksMinedDown = stats.blocksMinedDown + 1
        end
        turtle.attackDown()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y - 1  -- Always update
    return true
end

----------------------------------
-- DIRECTION CONTROL
----------------------------------
local function turnTo(targetDir)
    while facing ~= targetDir do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
end

----------------------------------
-- ABSOLUTE POSITION MOVEMENT
----------------------------------
local function moveAbs(targetX, targetY, targetZ, _depth)
    _depth = _depth or 0  -- Track recursion depth
    
    if _depth > 2 then
        print("⚠ Max correction attempts reached")
        print("  Position may not be exact")
        return true  -- Stop recursion
    end
    
    print(string.format("→ Moving to: %d, %d, %d", targetX, targetY, targetZ))
    
    -- Get initial GPS position
    local x, y, z = gps.locate(5)
    if x then
        lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
    end
    
    print(string.format("  Starting from: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
    
    -- Show movement plan
    local xMove = targetX - lastKnown.x
    local yMove = targetY - lastKnown.y
    local zMove = targetZ - lastKnown.z
    print(string.format("  Movement needed: X%+d, Y%+d, Z%+d", xMove, yMove, zMove))
    
    if math.abs(xMove) > 0 then
        if xMove > 0 then
            print(string.format("    → Will move East %d blocks (X: %d to %d)", xMove, lastKnown.x, targetX))
        else
            print(string.format("    → Will move West %d blocks (X: %d to %d)", math.abs(xMove), lastKnown.x, targetX))
        end
    end
    
    if math.abs(yMove) > 0 then
        if yMove > 0 then
            print(string.format("    → Will move Up %d blocks (Y: %d to %d)", yMove, lastKnown.y, targetY))
        else
            print(string.format("    → Will move Down %d blocks (Y: %d to %d)", math.abs(yMove), lastKnown.y, targetY))
        end
    end
    
    if math.abs(zMove) > 0 then
        if zMove > 0 then
            print(string.format("    → Will move South %d blocks (Z: %d to %d)", zMove, lastKnown.z, targetZ))
        else
            print(string.format("    → Will move North %d blocks (Z: %d to %d)", math.abs(zMove), lastKnown.z, targetZ))
        end
    end
    
    local moveCount = 0
    local maxMoves = 500
    
    -- Move vertically first (use lastKnown for position)
    while lastKnown.y < targetY and moveCount < maxMoves do
        tryUp()
        moveCount = moveCount + 1
        
        -- GPS check every 5 blocks to correct drift
        if moveCount % 5 == 0 then
            local gx, gy, gz = gps.locate(5)
            if gx then
                lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                print(string.format("  Y progress: Up %d (GPS: %d, %d, %d)", moveCount, lastKnown.x, lastKnown.y, lastKnown.z))
            end
        end
    end
    
    moveCount = 0
    while lastKnown.y > targetY and moveCount < maxMoves do
        tryDown()
        moveCount = moveCount + 1
        
        -- GPS check every 5 blocks to correct drift
        if moveCount % 5 == 0 then
            local gx, gy, gz = gps.locate(5)
            if gx then
                lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                print(string.format("  Y progress: Down %d (GPS: %d, %d, %d)", moveCount, lastKnown.x, lastKnown.y, lastKnown.z))
            end
        end
    end
    
    -- Move on X axis with smart obstacle avoidance
    moveCount = 0
    local failCount = 0
    
    -- GPS check before X movement
    local gx, gy, gz = gps.locate(5)
    if gx then
        lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
        print(string.format("X-axis start: Current=%d, Target=%d, Diff=%d", lastKnown.x, targetX, targetX - lastKnown.x))
    end
    
    local lastDistance = math.abs(targetX - lastKnown.x)
    
    while lastKnown.x ~= targetX and moveCount < maxMoves do
        -- Recalculate direction based on current position
        local xDiff = targetX - lastKnown.x
        if xDiff > 0 then 
            turnTo(1)  -- East (X+)
            if moveCount == 0 then
                print(string.format("  Moving East %d blocks... (facing=%d, expecting X to INCREASE)", xDiff, facing))
            end
        elseif xDiff < 0 then 
            turnTo(3)  -- West (X-)
            if moveCount == 0 then
                print(string.format("  Moving West %d blocks... (facing=%d, expecting X to DECREASE)", math.abs(xDiff), facing))
            end
        else
            break  -- Already at target X
        end
        
        local success = tryForward()
        
        -- Verify direction after first move
        if success and moveCount == 0 then
            local vx, vy, vz = gps.locate(5)
            if vx then
                local actualX = math.floor(vx)
                local actualZ = math.floor(vz)
                local oldX = lastKnown.x
                local oldZ = lastKnown.z
                
                print(string.format("    Direction check: X %d→%d, Z %d→%d", oldX, actualX, oldZ, actualZ))
                
                -- Check if we moved on the correct axis (X should change, Z should NOT)
                local xChanged = (actualX ~= oldX)
                local zChanged = (actualZ ~= oldZ)
                
                if not xChanged and zChanged then
                    print("    ✗✗ CRITICAL ERROR: Moving on Z axis instead of X!")
                    print("    ✗✗ Direction mapping is WRONG!")
                    print("    Stopping X movement...")
                    break  -- Exit X movement loop
                end
                
                if (xDiff > 0 and actualX <= oldX) or (xDiff < 0 and actualX >= oldX) then
                    print("    ✗ WRONG DIRECTION on X axis!")
                    print("    Turning around...")
                    turtle.turnRight()
                    turtle.turnRight()
                    facing = (facing + 2) % 4
                end
                lastKnown = {x=actualX, y=math.floor(vy), z=actualZ}
            end
        end
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- GPS check every 5 blocks to correct drift
            if moveCount % 5 == 0 then
                local gx, gy, gz = gps.locate(5)
                if gx then
                    local oldPos = lastKnown
                    lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                    local remaining = math.abs(targetX - lastKnown.x)
                    print(string.format("  X progress: %d (GPS: %d, %d, %d) - %d blocks to go", moveCount, lastKnown.x, lastKnown.y, lastKnown.z, remaining))
                    
                    -- CRITICAL: Check if distance is INCREASING (moving wrong way!)
                    if remaining > lastDistance + 2 then
                        print("  ✗ ERROR: Moving AWAY from target!")
                        print(string.format("    Was %d blocks away, now %d blocks away", lastDistance, remaining))
                        print("    Direction is WRONG! Breaking out...")
                        break  -- Exit loop and recalculate
                    end
                    lastDistance = remaining
                    
                    -- Check if we need to change direction
                    if (oldPos.x < targetX) ~= (lastKnown.x < targetX) then
                        print("  ⚠ Correcting direction...")
                    end
                else
                    print(string.format("  X progress: %d", moveCount))
                end
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(xDiff) > 0 and moveCount >= math.abs(xDiff) + 5 then
            print("  X: Reached expected distance")
            break
        end
    end
    
    -- Move on Z axis with smart obstacle avoidance
    moveCount = 0
    failCount = 0
    
    -- GPS check before Z movement
    local gx, gy, gz = gps.locate(5)
    if gx then
        lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
        print(string.format("Z-axis start: Current=%d, Target=%d, Diff=%d", lastKnown.z, targetZ, targetZ - lastKnown.z))
    end
    
    local lastDistance = math.abs(targetZ - lastKnown.z)
    
    while lastKnown.z ~= targetZ and moveCount < maxMoves do
        -- Recalculate direction based on current position
        local zDiff = targetZ - lastKnown.z
        if zDiff > 0 then 
            turnTo(2)  -- South (Z+)
            if moveCount == 0 then
                print(string.format("  Moving South %d blocks... (facing=%d, expecting Z to INCREASE)", zDiff, facing))
            end
        elseif zDiff < 0 then 
            turnTo(0)  -- North (Z-)
            if moveCount == 0 then
                print(string.format("  Moving North %d blocks... (facing=%d, expecting Z to DECREASE)", math.abs(zDiff), facing))
            end
        else
            break  -- Already at target Z
        end
        
        local success = tryForward()
        
        -- Verify direction after first move
        if success and moveCount == 0 then
            local vx, vy, vz = gps.locate(5)
            if vx then
                local actualX = math.floor(vx)
                local actualZ = math.floor(vz)
                local oldX = lastKnown.x
                local oldZ = lastKnown.z
                
                print(string.format("    Direction check: X %d→%d, Z %d→%d", oldX, actualX, oldZ, actualZ))
                
                -- Check if we moved on the correct axis (Z should change, X should NOT)
                local xChanged = (actualX ~= oldX)
                local zChanged = (actualZ ~= oldZ)
                
                if xChanged and not zChanged then
                    print("    ✗✗ CRITICAL ERROR: Moving on X axis instead of Z!")
                    print("    ✗✗ Direction mapping is WRONG!")
                    print("    Stopping Z movement...")
                    break  -- Exit Z movement loop
                end
                
                if (zDiff > 0 and actualZ <= oldZ) or (zDiff < 0 and actualZ >= oldZ) then
                    print("    ✗ WRONG DIRECTION on Z axis!")
                    print("    Turning around...")
                    turtle.turnRight()
                    turtle.turnRight()
                    facing = (facing + 2) % 4
                end
                lastKnown = {x=actualX, y=math.floor(vy), z=actualZ}
            end
        end
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- GPS check every 5 blocks to correct drift
            if moveCount % 5 == 0 then
                local gx, gy, gz = gps.locate(5)
                if gx then
                    local oldPos = lastKnown
                    lastKnown = {x=math.floor(gx), y=math.floor(gy), z=math.floor(gz)}
                    local remaining = math.abs(targetZ - lastKnown.z)
                    print(string.format("  Z progress: %d (GPS: %d, %d, %d) - %d blocks to go", moveCount, lastKnown.x, lastKnown.y, lastKnown.z, remaining))
                    
                    -- CRITICAL: Check if distance is INCREASING (moving wrong way!)
                    if remaining > lastDistance + 2 then
                        print("  ✗ ERROR: Moving AWAY from target!")
                        print(string.format("    Was %d blocks away, now %d blocks away", lastDistance, remaining))
                        print("    Direction is WRONG! Breaking out...")
                        break  -- Exit loop and recalculate
                    end
                    lastDistance = remaining
                    
                    -- Check if we need to change direction
                    if (oldPos.z < targetZ) ~= (lastKnown.z < targetZ) then
                        print("  ⚠ Correcting direction...")
                    end
                else
                    print(string.format("  Z progress: %d", moveCount))
                end
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(zDiff) > 0 and moveCount >= math.abs(zDiff) + 5 then
            print("  Z: Reached expected distance")
            break
        end
    end
    
    -- Final GPS check with correction
    print("Verifying final position with GPS...")
    local fx, fy, fz = gps.locate(5)
    if fx then
        lastKnown = {x=math.floor(fx), y=math.floor(fy), z=math.floor(fz)}
        local distance = math.abs(lastKnown.x - targetX) + math.abs(lastKnown.y - targetY) + math.abs(lastKnown.z - targetZ)
        
        if distance == 0 then
            print(string.format("✓ Arrived at: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            return true
        elseif distance <= 3 then
            print(string.format("✓ Close: %d, %d, %d (off by %d)", lastKnown.x, lastKnown.y, lastKnown.z, distance))
            
            -- Try to correct small offset (EXACT positioning required)
            print("  Fine-tuning to EXACT position...")
            
            -- Y axis first
            while lastKnown.y < targetY do
                print(string.format("  Moving up (Y: %d → %d)", lastKnown.y, targetY))
                if not tryUp() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.y > targetY do
                print(string.format("  Moving down (Y: %d → %d)", lastKnown.y, targetY))
                if not tryDown() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- X axis
            while lastKnown.x < targetX do
                print(string.format("  Moving East (X: %d → %d)", lastKnown.x, targetX))
                turnTo(1)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.x > targetX do
                print(string.format("  Moving West (X: %d → %d)", lastKnown.x, targetX))
                turnTo(3)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- Z axis
            while lastKnown.z < targetZ do
                print(string.format("  Moving South (Z: %d → %d)", lastKnown.z, targetZ))
                turnTo(2)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            while lastKnown.z > targetZ do
                print(string.format("  Moving North (Z: %d → %d)", lastKnown.z, targetZ))
                turnTo(0)
                if not tryForward() then break end
                local tx, ty, tz = gps.locate(5)
                if tx then lastKnown = {x=math.floor(tx), y=math.floor(ty), z=math.floor(tz)} end
            end
            
            -- Final check
            fx, fy, fz = gps.locate(5)
            if fx then
                lastKnown = {x=math.floor(fx), y=math.floor(fy), z=math.floor(fz)}
                distance = math.abs(lastKnown.x - targetX) + math.abs(lastKnown.y - targetY) + math.abs(lastKnown.z - targetZ)
                if distance == 0 then
                    print(string.format("✓ EXACT position: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
                else
                    print(string.format("✓ Best effort: %d, %d, %d (off by %d)", lastKnown.x, lastKnown.y, lastKnown.z, distance))
                end
            end
            
            return true
        else
            print(string.format("⚠ Off by %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            print(string.format("  Target: %d, %d, %d", targetX, targetY, targetZ))
            print("  Attempting correction...")
            
            -- Try to move to exact position (with recursion limit)
            return moveAbs(targetX, targetY, targetZ, _depth + 1)  -- Recursive call
        end
    else
        print("⚠ GPS unavailable for final check")
        print("  Using dead reckoning position")
        print(string.format("  Estimated: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
        return true
    end
end

----------------------------------
-- PATH EXECUTION
----------------------------------
local function executePathSteps(steps)
    if not steps or #steps == 0 then
        return false
    end
    
    print(string.format("Executing path: %d steps", #steps))
    
    for i, step in ipairs(steps) do
        if i % 10 == 0 then
            print(string.format("  Step %d/%d", i, #steps))
        end
        moveAbs(step.x, step.y, step.z)
    end
    
    print("✓ Path complete")
    return true
end

----------------------------------
-- FUEL MANAGEMENT
----------------------------------
local function invRefuel(amountNeeded)
    local startFuel = turtle.getFuelLevel()
    local targetFuel = startFuel + (amountNeeded or 1000)
    
    for slot = 1, 16 do
        if turtle.getFuelLevel() >= targetFuel then
            break
        end
        
        turtle.select(slot)
        if turtle.refuel(0) then
            local itemCount = turtle.getItemCount(slot)
            for i = 1, itemCount do
                if turtle.getFuelLevel() >= targetFuel then
                    break
                end
                turtle.refuel(1)
            end
        end
    end
    turtle.select(1)
    
    local gained = turtle.getFuelLevel() - startFuel
    if gained > 0 then
        print(string.format("Refueled: +%d (now %d)", gained, turtle.getFuelLevel()))
    end
    return gained
end

local function smartRefuel()
    local current = turtle.getFuelLevel()
    local pos = getPos()
    
    local homeTrip = math.abs(homePos.x - pos.x) + 
                     math.abs(homePos.y - pos.y) + 
                     math.abs(homePos.z - pos.z)
    local buffer = 500
    local needed = homeTrip + buffer
    
    if current < needed then
        print(string.format("Low fuel: %d/%d", current, needed))
        invRefuel(needed - current + 200)
        return true
    end
    return false
end

----------------------------------
-- INVENTORY MANAGEMENT
----------------------------------
local KEEP_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod"
}

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function depositToChest()
    print("Depositing to chest...")
    
    -- First, make sure we're at exact home position
    local px, py, pz = gps.locate(5)
    if px then
        local currentX, currentY, currentZ = math.floor(px), math.floor(py), math.floor(pz)
        print(string.format("  Current: %d, %d, %d", currentX, currentY, currentZ))
        print(string.format("  Home:    %d, %d, %d", homePos.x, homePos.y, homePos.z))
        
        -- Check if we need position correction
        if currentX ~= homePos.x or currentY ~= homePos.y or currentZ ~= homePos.z then
            print("  ⚠ Position mismatch! Correcting...")
            moveAbs(homePos.x, homePos.y, homePos.z)
        end
    end
    
    -- Scan all 4 directions to find chest
    print("  Scanning for chest...")
    local chestFound = false
    local chestDirection = nil
    
    for dir = 0, 3 do
        turnTo(dir)
        local ok, blockData = turtle.inspect()
        if ok and blockData.name and string.find(blockData.name, "chest") then
            print(string.format("  ✓ Found chest at direction %d", dir))
            chestFound = true
            chestDirection = dir
            break
        end
    end
    
    if not chestFound then
        print("ERROR: Chest not found in any direction!")
        print("Checking up and down...")
        
        -- Check up
        local ok, blockData = turtle.inspectUp()
        if ok and blockData.name and string.find(blockData.name, "chest") then
            print("  ✗ Chest is ABOVE! Y-level wrong!")
            print("  Moving up 1 block...")
            tryUp()
            homePos.y = homePos.y + 1
            saveHomeLocation()
            return depositToChest()  -- Retry
        end
        
        -- Check down
        ok, blockData = turtle.inspectDown()
        if ok and blockData.name and string.find(blockData.name, "chest") then
            print("  ✗ Chest is BELOW! Y-level wrong!")
            print("  Moving down 1 block...")
            tryDown()
            homePos.y = homePos.y - 1
            saveHomeLocation()
            return depositToChest()  -- Retry
        end
        
        print("Keeping items in inventory...")
        
        -- Notify computer
        rednet.send(COMPUTER_ID, {
            type = "status_update",
            status = "ERROR: No chest at home!",
            position = homePos
        }, PROTOCOL)
        
        return false
    end
    
    -- Face the chest and update homeFacing
    turnTo(chestDirection)
    
    -- Update homeFacing to face AWAY from chest
    homeFacing = (chestDirection + 2) % 4
    saveHomeLocation()  -- Save corrected direction
    print(string.format("  Updated home facing: %d (away from chest)", homeFacing))
    
    -- Chest found, deposit items
    local deposited = 0
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item and not isFuelItem(item.name) then
            turtle.select(i)
            if turtle.drop() then
                deposited = deposited + 1
            end
        end
    end
    
    print(string.format("✓ Deposited %d items", deposited))
    
    -- Turn to face away from chest (home direction)
    turnTo(homeFacing)
    
    smartRefuel()
    return true
end

local function inventoryAlmostFull()
    local emptySlots = 0
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            emptySlots = emptySlots + 1
        end
    end
    return emptySlots <= 3
end

----------------------------------
-- COMMUNICATION WITH COMPUTER
----------------------------------
local function requestPath()
    local pos = getPos()
    print(string.format("Requesting path from %d,%d,%d", pos.x, pos.y, pos.z))
    
    rednet.send(COMPUTER_ID, {
        type = "request_path",
        x = pos.x,
        y = pos.y,
        z = pos.z,
        oreFilter = ORE_FILTER  -- Send ore filter to computer
    }, PROTOCOL)
    
    local id, msg = rednet.receive(PROTOCOL, 10)
    if id and msg and msg.type == "path" then
        stats.pathsReceived = stats.pathsReceived + 1
        if msg.steps and #msg.steps > 0 then
            print(string.format("✓ Path received: %d steps", #msg.steps))
            return msg.steps, msg.target
        else
            print("No ores available")
            return nil, nil
        end
    end
    
    print("No response from computer")
    return nil, nil
end

local function requestScan()
    local pos = getPos()
    print("Requesting scan...")
    
    rednet.send(COMPUTER_ID, {
        type = "request_scan",
        x = pos.x,
        y = pos.y,
        z = pos.z
    }, PROTOCOL)
    
    stats.scansRequested = stats.scansRequested + 1
end

local function reportOreMined(target)
    rednet.send(COMPUTER_ID, {
        type = "ore_mined",
        x = target.x,
        y = target.y,
        z = target.z
    }, PROTOCOL)
    
    print(string.format("✓ Reported ore mined at %d,%d,%d", target.x, target.y, target.z))
end

----------------------------------
-- MAIN MINING LOOP
----------------------------------
print("")
print("Starting mining operations...")
print("Press Ctrl+T to stop")
print("")
print("Testing connection to computer...")

-- Test connection first
rednet.send(COMPUTER_ID, {type = "ping"}, PROTOCOL)
local testId, testMsg = rednet.receive(PROTOCOL, 3)
if testId then
    print("✓ Connected to computer ID:", COMPUTER_ID)
else
    print("⚠ Cannot reach computer ID:", COMPUTER_ID)
    print("Scanner appears offline. Continuing anyway...")
    print("Note: Turtle will work in standalone mode")
    print("  - No ore coordination with scanner")
    print("  - Will mine randomly if no scanner")
    print("")
    print("To fix later:")
    print("  1. Start scanner computer")
    print("  2. Check COMPUTER_ID matches")
    print("  3. Restart turtle")
    print("")
    sleep(3)  -- Show message for 3 seconds
end

----------------------------------
-- AUTO-RETURN HOME (if saved home exists)
----------------------------------
if savedHome then
    print("Checking position...")
    
    -- Get position with GPS validation
    print("Getting GPS coordinates...")
    local x, y, z = gps.locate(5)
    
    if not x then
        print("═══════════════════════════════════")
        print("ERROR: GPS signal not available!")
        print("═══════════════════════════════════")
        print("Cannot determine current position")
        print("")
        print("Solutions:")
        print("  1. Set up GPS satellites")
        print("  2. Move turtle closer to GPS")
        print("  3. Manually move turtle to home:")
        print(string.format("     %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Press ENTER to skip position check...")
        read()
    else
        local currentPos = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
        lastKnown = currentPos
        
        print(string.format("✓ GPS Position: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
        
        local atHome = (currentPos.x == homePos.x and 
                       currentPos.y == homePos.y and 
                       currentPos.z == homePos.z)
        
        if not atHome then
            local distance = math.abs(currentPos.x - homePos.x) + 
                           math.abs(currentPos.y - homePos.y) + 
                           math.abs(currentPos.z - homePos.z)
            
            print(string.format("⚠ Not at home! Distance: %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
            print(string.format("  Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
            print("")
            print("AUTO-NAVIGATING back to home base...")
            print("(This may take a while)")
            print("")
            
            -- Auto-navigate to home
            moveAbs(homePos.x, homePos.y, homePos.z)
            
            print("✓ Arrived at home!")
            
            -- After navigation, direction might be wrong!
            -- Reset facing to unknown so chest check will find it
            print("Checking orientation...")
        else
            print("✓ Turtle at home position")
        end
    end
    
    -- Verify chest is accessible (always check all directions!)
    print("Verifying chest...")
    
    -- Try all 4 directions to find chest
    local chestFound = false
    local chestDirection = nil
    local dirNames = {[0]="North", [1]="East", [2]="South", [3]="West"}
    
    print("  Scanning all directions...")
    for dir = 0, 3 do
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name then
            print(string.format("  Direction %d (%s): %s", facing, dirNames[facing], blockData.name))
            if string.find(blockData.name, "chest") then
                chestFound = true
                chestDirection = facing
                print(string.format("✓ Chest found facing %s (direction %d)", dirNames[facing], facing))
                
                -- Turtle is currently FACING the chest
                -- We need to face AWAY from chest
                print("  Turning to face away from chest...")
                turtle.turnLeft()
                turtle.turnLeft()
                facing = (facing + 2) % 4
                
                -- This is the correct home facing
                homeFacing = facing
                
                print(string.format("✓ Now facing %s (away from chest)", dirNames[facing]))
                
                -- Save corrected facing
                saveHomeLocation(homePos, homeFacing)
                print("✓ Direction saved")
                break
            end
        else
            print(string.format("  Direction %d (%s): Nothing", facing, dirNames[facing]))
        end
        
        -- Try next direction
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    if not chestFound then
        print("")
        print("═══════════════════════════════════")
        print("ERROR: Chest not found at home!")
        print("═══════════════════════════════════")
        print("Checked all 4 directions")
        print(string.format("Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Please:")
        print("  1. Place chest next to turtle")
        print("  2. OR delete home_location.txt")
        print("  3. Then restart miner_v2")
        print("═══════════════════════════════════")
        error("Chest verification failed")
    end
    
    print("✓ Chest verified and direction corrected!")
    
    print("✓ Ready to mine!")
    print("")
end

-- Initial scan request
print("Requesting initial scan...")
requestScan()
sleep(2)

----------------------------------
-- COMMAND HANDLER
----------------------------------
local function checkCommands()
    -- Check for commands from computer (non-blocking)
    local senderId, message = rednet.receive(PROTOCOL, 0)
    if senderId and message then
        if message.type == "return_home" then
            print("")
            print("═══════════════════════════════════")
            print("*** RETURN HOME command received! ***")
            print("═══════════════════════════════════")
            
            -- Send acknowledgment
            rednet.send(COMPUTER_ID, {
                type = "status_update",
                status = "returning home",
                position = getPos()
            }, PROTOCOL)
            
            print("Returning to base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            
            -- Send arrived status
            rednet.send(COMPUTER_ID, {
                type = "status_update", 
                status = "at home",
                position = homePos
            }, PROTOCOL)
            
            print("✓ At home. Resuming in 5 seconds...")
            print("(Press Ctrl+T to stop)")
            print("═══════════════════════════════════")
            sleep(5)
            return true
        end
    end
    return false
end

local miningCycle = 0
local idleCount = 0

while true do
    -- Check for commands at start of cycle
    checkCommands()
    
    miningCycle = miningCycle + 1
    print(string.format("=== Cycle %d ===", miningCycle))
    
    -- Check inventory
    if inventoryAlmostFull() then
        print("Inventory full - returning home")
        moveAbs(homePos.x, homePos.y, homePos.z)
        depositToChest()
    end
    
    -- Check for commands after deposit
    checkCommands()
    
    -- Check fuel
    smartRefuel()
    
    -- Check for commands before requesting path
    checkCommands()
    
    -- Request path to next ore
    local steps, target = requestPath()
    
    if steps and target then
        idleCount = 0
        
        -- Execute path
        print(string.format("Target: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        local success = false
        local ok, err = pcall(function()
            success = executePathSteps(steps)
        end)
        
        if not ok then
            print("ERROR moving to ore:", err)
            print("Reporting ore as unreachable...")
            rednet.send(COMPUTER_ID, {
                type = "ore_failed",
                x = target.x,
                y = target.y,
                z = target.z
            }, PROTOCOL)
        elseif success then
            -- Check if we're actually at the ore location
            local pos = getPos()
            local dist = math.abs(pos.x - target.x) + math.abs(pos.y - target.y) + math.abs(pos.z - target.z)
            
            if dist <= 1 then
                -- We're close enough, mine it
                print("Mining ore...")
                turtle.dig()
                turtle.digDown()
                turtle.digUp()
                stats.oresMined = stats.oresMined + 1
                
                -- Report to computer
                reportOreMined(target)
                
                sleep(0.5)
            else
                print(string.format("Not close enough to ore (distance: %d)", dist))
                print("Reporting as unreachable...")
                rednet.send(COMPUTER_ID, {
                    type = "ore_failed",
                    x = target.x,
                    y = target.y,
                    z = target.z
                }, PROTOCOL)
            end
        end
        
        -- Check for commands after mining
        checkCommands()
    else
        -- No ores available
        idleCount = idleCount + 1
        print(string.format("Idle (no ores) - count: %d", idleCount))
        
        -- Check for commands during idle
        checkCommands()
        
        if idleCount >= 3 then
            print("Requesting new scan...")
            requestScan()
            idleCount = 0
        end
        
        -- Emergency: If scanner not responding, return home
        if idleCount >= 6 then
            print("WARNING: Scanner not responding!")
            print("Returning to home base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            print("At home. Waiting for scanner...")
            sleep(30)
            idleCount = 0
        end
        
        sleep(5)
    end
    
    -- Periodic refuel and smart checks
    smartRefuel()
end

----------------------------------
-- CLEANUP (unreachable but good practice)
----------------------------------
print("")
print("Returning home...")
moveAbs(homePos.x, homePos.y, homePos.z)
depositToChest()

print("")
print("═══════════════════════════════════")
print("  MINING COMPLETE")
print("═══════════════════════════════════")
print(string.format("Ores mined: %d", stats.oresMined))
print(string.format("Total moves: %d", stats.totalMoves))
print(string.format("Free moves: %d (%.1f%%)", 
    stats.freeMoves, (stats.freeMoves / math.max(1, stats.totalMoves) * 100)))
print("")
print(string.format("Blocks mined: %d", 
    stats.blocksMinedForward + stats.blocksMinedUp + stats.blocksMinedDown))
print(string.format("  Forward: %d", stats.blocksMinedForward))
print(string.format("  Up: %d", stats.blocksMinedUp))
print(string.format("  Down: %d", stats.blocksMinedDown))
print("")
print(string.format("Paths received: %d", stats.pathsReceived))
print(string.format("Scans requested: %d", stats.scansRequested))
print("═══════════════════════════════════")
