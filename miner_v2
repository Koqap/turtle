-- SmartMiner Turtle V2 - A* Pathfinding Client
-- Works with computer brain for coordinated mining

----------------------------------
-- CONFIGURATION
----------------------------------
local COMPUTER_ID = 3                -- ID of the computer brain
local PROTOCOL = "smartminer"        -- Must match computer
local TURTLE_ID = os.getComputerID and os.getComputerID() or 2

-- ORE FILTER: Which ores to mine (set to nil to mine ALL ores)
local ORE_FILTER = {
    "iron",      -- Mine iron ore
    "coal",      -- Mine coal ore
    "gold",      -- Mine gold ore
    "diamond",   -- Mine diamond ore
    -- "copper",    -- Uncomment to mine copper
    -- "redstone",  -- Uncomment to mine redstone
    -- "lapis",     -- Uncomment to mine lapis
    -- "emerald",   -- Uncomment to mine emerald
}
-- Set to nil to mine ALL ore types: local ORE_FILTER = nil

----------------------------------
-- MOVEMENT STATISTICS
----------------------------------
local stats = {
    blocksMinedForward = 0,
    blocksMinedUp = 0,
    blocksMinedDown = 0,
    freeMoves = 0,
    totalMoves = 0,
    oresMined = 0,
    pathsReceived = 0,
    scansRequested = 0,
}

----------------------------------
-- MODEM AUTO-DETECTION
----------------------------------
local function findAndOpenModem()
    -- Try to find wireless modem on any side
    for _, side in ipairs({"right", "left", "top", "bottom", "front", "back"}) do
        if peripheral.getType(side) and peripheral.getType(side):find("modem") then
            local m = peripheral.wrap(side)
            if m.isWireless and m.isWireless() then
                rednet.open(side)
                print("Modem found on:", side)
                return true
            end
        end
    end
    return false
end

if not findAndOpenModem() then
    error("ERROR: No wireless modem found!")
end

----------------------------------
-- GPS AND POSITION TRACKING
----------------------------------
local gps = gps  -- Use built-in GPS
local lastKnown = {x=0, y=0, z=0}
local facing = 0  -- 0=north, 1=east, 2=south, 3=west

local function getPos()
    -- Try GPS multiple times
    for attempt = 1, 3 do
        local x, y, z = gps.locate(5)
        if x then 
            lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
            return lastKnown
        end
        if attempt < 3 then
            sleep(1)
        end
    end
    -- Fallback to internal tracking (may be inaccurate!)
    return lastKnown
end

----------------------------------
-- PERSISTENT STORAGE
----------------------------------
local HOME_FILE = "home_location.txt"

local function saveHomeLocation(pos, face)
    local f = fs.open(HOME_FILE, "w")
    if f then
        f.writeLine(textutils.serialize({
            x = pos.x,
            y = pos.y,
            z = pos.z,
            facing = face
        }))
        f.close()
        print("✓ Home location saved")
        return true
    end
    return false
end

local function loadHomeLocation()
    if fs.exists(HOME_FILE) then
        local f = fs.open(HOME_FILE, "r")
        if f then
            local data = f.readAll()
            f.close()
            local ok, result = pcall(function() return textutils.unserialize(data) end)
            if ok and result then
                print("✓ Found saved home location")
                return result
            end
        end
    end
    return nil
end

----------------------------------
-- BASE STATION CHEST SETUP
----------------------------------
print("═══════════════════════════════════")
print("  SMARTMINER TURTLE V2")
print("═══════════════════════════════════")
print("Turtle ID:", TURTLE_ID)
print("Computer ID:", COMPUTER_ID)
print("")

local homePos
local homeFacing

-- Try to load saved home location
local savedHome = loadHomeLocation()

if savedHome then
    -- Auto-load saved location without prompting
    homePos = {x=savedHome.x, y=savedHome.y, z=savedHome.z}
    homeFacing = savedHome.facing
    facing = homeFacing
    print(string.format("✓ Loaded home: %d, %d, %d", savedHome.x, savedHome.y, savedHome.z))
    print(string.format("✓ Facing: %s", ({"north","east","south","west"})[homeFacing+1] or "unknown"))
    print("(Position check will happen after loading functions...)")
    print("")
else
    -- First time setup
    print("FIRST TIME SETUP")
    print("")
    print("Place chest BEHIND turtle")
    print("(Turtle should face AWAY from chest)")
    print("")
    print("Press ENTER when ready...")
    read()

    -- Save home position
    print("Getting home position...")
    homePos = getPos()
    print(string.format("✓ Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))

    -- Verify chest
    print("Verifying chest...")
    turtle.turnLeft()
    turtle.turnLeft()

    local ok, chestData = turtle.inspect()
    if not ok or not string.find(chestData.name or "", "chest") then
        turtle.turnLeft()
        turtle.turnLeft()
        error("ERROR: No chest found behind turtle!")
    end

    print("✓ Chest detected!")
    turtle.turnLeft()
    turtle.turnLeft()
end

----------------------------------
-- DETECT FACING DIRECTION
----------------------------------
local function detectFacing()
    local x1, y1, z1 = getPos().x, getPos().y, getPos().z
    
    -- Try to move forward
    local moved = false
    for attempt = 1, 5 do
        if turtle.forward() then
            moved = true
            break
        end
        turtle.dig()
        turtle.attack()
        sleep(0.3)
    end
    
    if not moved then
        print("WARNING: Cannot detect facing (blocked)")
        return 0  -- Default to north
    end
    
    local x2, y2, z2 = getPos().x, getPos().y, getPos().z
    local dx, dz = x2 - x1, z2 - z1
    
    turtle.back()  -- Return to start
    
    if dz == -1 then return 0 end     -- North
    if dx == 1 then return 1 end      -- East
    if dz == 1 then return 2 end      -- South
    if dx == -1 then return 3 end     -- West
    return 0  -- Default
end

-- Only detect facing if first-time setup (no saved home)
if not homeFacing then
    print("Detecting facing direction...")
    facing = detectFacing()
    homeFacing = facing
    
    local dirNames = {[0]="north", [1]="east", [2]="south", [3]="west"}
    print(string.format("✓ Facing: %s", dirNames[facing]))
    
    -- Save the home location with facing
    saveHomeLocation(homePos, homeFacing)
    print(string.format("✓ Home saved: %d,%d,%d", homePos.x, homePos.y, homePos.z))
end

print("✓ Setup complete")
print("═══════════════════════════════════")

----------------------------------
-- SMART MOVEMENT FUNCTIONS
----------------------------------
local function tryForward()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.forward() then
        stats.freeMoves = stats.freeMoves + 1
        -- ALWAYS update internal position for dead reckoning
        if facing == 0 then lastKnown.z = lastKnown.z - 1
        elseif facing == 1 then lastKnown.x = lastKnown.x + 1
        elseif facing == 2 then lastKnown.z = lastKnown.z + 1
        elseif facing == 3 then lastKnown.x = lastKnown.x - 1
        end
        return true
    end
    
    -- Blocked - dig and retry
    while not turtle.forward() do
        -- Check if it's a chest - DON'T DIG IT!
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name and string.find(blockData.name, "chest") then
            print("⚠ Chest detected! Avoiding...")
            return false  -- Don't dig chest, return failure
        end
        
        if turtle.dig() then
            stats.blocksMinedForward = stats.blocksMinedForward + 1
        end
        turtle.attack()
        sleep(0.1)
    end
    
    -- ALWAYS update position after successful move
    if facing == 0 then lastKnown.z = lastKnown.z - 1
    elseif facing == 1 then lastKnown.x = lastKnown.x + 1
    elseif facing == 2 then lastKnown.z = lastKnown.z + 1
    elseif facing == 3 then lastKnown.x = lastKnown.x - 1
    end
    return true
end

local function tryUp()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.up() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y + 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.up() do
        if turtle.digUp() then
            stats.blocksMinedUp = stats.blocksMinedUp + 1
        end
        turtle.attackUp()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y + 1  -- Always update
    return true
end

local function tryDown()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.down() then
        stats.freeMoves = stats.freeMoves + 1
        lastKnown.y = lastKnown.y - 1  -- Always update for dead reckoning
        return true
    end
    
    while not turtle.down() do
        if turtle.digDown() then
            stats.blocksMinedDown = stats.blocksMinedDown + 1
        end
        turtle.attackDown()
        sleep(0.1)
    end
    
    lastKnown.y = lastKnown.y - 1  -- Always update
    return true
end

----------------------------------
-- DIRECTION CONTROL
----------------------------------
local function turnTo(targetDir)
    while facing ~= targetDir do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
end

----------------------------------
-- ABSOLUTE POSITION MOVEMENT
----------------------------------
local function moveAbs(targetX, targetY, targetZ)
    print(string.format("→ Moving to: %d, %d, %d", targetX, targetY, targetZ))
    
    -- Get initial GPS position
    local x, y, z = gps.locate(5)
    if x then
        lastKnown = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
    end
    
    print(string.format("  Starting from: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
    
    local moveCount = 0
    local maxMoves = 500
    
    -- Move vertically first (use lastKnown for position)
    while lastKnown.y < targetY and moveCount < maxMoves do
        tryUp()
        moveCount = moveCount + 1
    end
    
    moveCount = 0
    while lastKnown.y > targetY and moveCount < maxMoves do
        tryDown()
        moveCount = moveCount + 1
    end
    
    -- Move on X axis with smart obstacle avoidance
    local xDiff = targetX - lastKnown.x
    if xDiff > 0 then 
        turnTo(1)  -- East
        print(string.format("  Moving East %d blocks...", xDiff))
    elseif xDiff < 0 then 
        turnTo(3)  -- West
        print(string.format("  Moving West %d blocks...", math.abs(xDiff)))
    end
    
    moveCount = 0
    local failCount = 0
    while lastKnown.x ~= targetX and moveCount < maxMoves do
        local success = tryForward()
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- Progress update every 10 blocks
            if moveCount % 10 == 0 then
                print(string.format("  X progress: %d", moveCount))
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(xDiff) > 0 and moveCount >= math.abs(xDiff) + 5 then
            print("  X: Reached expected distance")
            break
        end
    end
    
    -- Move on Z axis with smart obstacle avoidance
    local zDiff = targetZ - lastKnown.z
    if zDiff > 0 then 
        turnTo(2)  -- South
        print(string.format("  Moving South %d blocks...", zDiff))
    elseif zDiff < 0 then 
        turnTo(0)  -- North
        print(string.format("  Moving North %d blocks...", math.abs(zDiff)))
    end
    
    moveCount = 0
    failCount = 0
    while lastKnown.z ~= targetZ and moveCount < maxMoves do
        local success = tryForward()
        
        if success then
            moveCount = moveCount + 1
            failCount = 0  -- Reset fail count on success
            
            -- Progress update every 10 blocks
            if moveCount % 10 == 0 then
                print(string.format("  Z progress: %d", moveCount))
            end
        else
            -- Failed to move forward (e.g., hit chest or unbreakable)
            failCount = failCount + 1
            
            if failCount > 3 then
                print("  ⚠ Blocked! Trying alternate path...")
                -- Try going up and around
                tryUp()
                if tryForward() then
                    tryDown()
                    moveCount = moveCount + 1
                    failCount = 0
                else
                    -- Still blocked, try down
                    tryDown()
                    tryDown()
                    if tryForward() then
                        tryUp()
                        moveCount = moveCount + 1
                        failCount = 0
                    else
                        tryUp()  -- Return to original Y level
                        print("  ✗ Cannot bypass obstacle!")
                        break
                    end
                end
            end
        end
        
        -- Safety: If we've moved expected distance, stop
        if math.abs(zDiff) > 0 and moveCount >= math.abs(zDiff) + 5 then
            print("  Z: Reached expected distance")
            break
        end
    end
    
    -- Final GPS check
    print("Verifying final position with GPS...")
    local fx, fy, fz = gps.locate(5)
    if fx then
        lastKnown = {x=math.floor(fx), y=math.floor(fy), z=math.floor(fz)}
        local distance = math.abs(lastKnown.x - targetX) + math.abs(lastKnown.y - targetY) + math.abs(lastKnown.z - targetZ)
        
        if distance == 0 then
            print(string.format("✓ Arrived at: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            return true
        elseif distance <= 2 then
            print(string.format("✓ Close enough: %d, %d, %d (distance: %d)", lastKnown.x, lastKnown.y, lastKnown.z, distance))
            return true
        else
            print(string.format("⚠ Off by %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", lastKnown.x, lastKnown.y, lastKnown.z))
            print(string.format("  Target: %d, %d, %d", targetX, targetY, targetZ))
            return false
        end
    else
        print("⚠ GPS unavailable for final check")
        print("  Assuming arrived based on movement count")
        return true
    end
end

----------------------------------
-- PATH EXECUTION
----------------------------------
local function executePathSteps(steps)
    if not steps or #steps == 0 then
        return false
    end
    
    print(string.format("Executing path: %d steps", #steps))
    
    for i, step in ipairs(steps) do
        if i % 10 == 0 then
            print(string.format("  Step %d/%d", i, #steps))
        end
        moveAbs(step.x, step.y, step.z)
    end
    
    print("✓ Path complete")
    return true
end

----------------------------------
-- FUEL MANAGEMENT
----------------------------------
local function invRefuel(amountNeeded)
    local startFuel = turtle.getFuelLevel()
    local targetFuel = startFuel + (amountNeeded or 1000)
    
    for slot = 1, 16 do
        if turtle.getFuelLevel() >= targetFuel then
            break
        end
        
        turtle.select(slot)
        if turtle.refuel(0) then
            local itemCount = turtle.getItemCount(slot)
            for i = 1, itemCount do
                if turtle.getFuelLevel() >= targetFuel then
                    break
                end
                turtle.refuel(1)
            end
        end
    end
    turtle.select(1)
    
    local gained = turtle.getFuelLevel() - startFuel
    if gained > 0 then
        print(string.format("Refueled: +%d (now %d)", gained, turtle.getFuelLevel()))
    end
    return gained
end

local function smartRefuel()
    local current = turtle.getFuelLevel()
    local pos = getPos()
    
    local homeTrip = math.abs(homePos.x - pos.x) + 
                     math.abs(homePos.y - pos.y) + 
                     math.abs(homePos.z - pos.z)
    local buffer = 500
    local needed = homeTrip + buffer
    
    if current < needed then
        print(string.format("Low fuel: %d/%d", current, needed))
        invRefuel(needed - current + 200)
        return true
    end
    return false
end

----------------------------------
-- INVENTORY MANAGEMENT
----------------------------------
local KEEP_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod"
}

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function depositToChest()
    print("Depositing to chest...")
    
    -- Turn to face home direction
    while facing ~= homeFacing do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    -- Turn around to face chest
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    -- Verify chest is still there
    local ok, blockData = turtle.inspect()
    if not ok or not string.find(blockData.name or "", "chest") then
        print("ERROR: Chest not found at home!")
        print("Expected chest behind home position")
        print("Please replace chest or reset home location")
        print("")
        print("Keeping items in inventory...")
        
        -- Turn back
        turtle.turnLeft()
        turtle.turnLeft()
        facing = (facing + 2) % 4
        
        -- Notify computer
        rednet.send(COMPUTER_ID, {
            type = "status_update",
            status = "ERROR: No chest at home!",
            position = homePos
        }, PROTOCOL)
        
        return false
    end
    
    -- Chest found, deposit items
    local deposited = 0
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item and not isFuelItem(item.name) then
            turtle.select(i)
            if turtle.drop() then
                deposited = deposited + 1
            end
        end
    end
    
    print(string.format("✓ Deposited %d items", deposited))
    
    -- Turn back
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    smartRefuel()
    return true
end

local function inventoryAlmostFull()
    local emptySlots = 0
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            emptySlots = emptySlots + 1
        end
    end
    return emptySlots <= 3
end

----------------------------------
-- COMMUNICATION WITH COMPUTER
----------------------------------
local function requestPath()
    local pos = getPos()
    print(string.format("Requesting path from %d,%d,%d", pos.x, pos.y, pos.z))
    
    rednet.send(COMPUTER_ID, {
        type = "request_path",
        x = pos.x,
        y = pos.y,
        z = pos.z,
        oreFilter = ORE_FILTER  -- Send ore filter to computer
    }, PROTOCOL)
    
    local id, msg = rednet.receive(PROTOCOL, 10)
    if id and msg and msg.type == "path" then
        stats.pathsReceived = stats.pathsReceived + 1
        if msg.steps and #msg.steps > 0 then
            print(string.format("✓ Path received: %d steps", #msg.steps))
            return msg.steps, msg.target
        else
            print("No ores available")
            return nil, nil
        end
    end
    
    print("No response from computer")
    return nil, nil
end

local function requestScan()
    local pos = getPos()
    print("Requesting scan...")
    
    rednet.send(COMPUTER_ID, {
        type = "request_scan",
        x = pos.x,
        y = pos.y,
        z = pos.z
    }, PROTOCOL)
    
    stats.scansRequested = stats.scansRequested + 1
end

local function reportOreMined(target)
    rednet.send(COMPUTER_ID, {
        type = "ore_mined",
        x = target.x,
        y = target.y,
        z = target.z
    }, PROTOCOL)
    
    print(string.format("✓ Reported ore mined at %d,%d,%d", target.x, target.y, target.z))
end

----------------------------------
-- MAIN MINING LOOP
----------------------------------
print("")
print("Starting mining operations...")
print("Press Ctrl+T to stop")
print("")
print("Testing connection to computer...")

-- Test connection first
rednet.send(COMPUTER_ID, {type = "ping"}, PROTOCOL)
local testId, testMsg = rednet.receive(PROTOCOL, 3)
if testId then
    print("✓ Connected to computer ID:", COMPUTER_ID)
else
    print("✗ Cannot reach computer ID:", COMPUTER_ID)
    print("Make sure:")
    print("  1. Scanner is running")
    print("  2. Both have wireless modems")
    print("  3. COMPUTER_ID is correct")
    print("")
    print("Press ENTER to continue anyway...")
    read()
end

----------------------------------
-- AUTO-RETURN HOME (if saved home exists)
----------------------------------
if savedHome then
    print("Checking position...")
    
    -- Get position with GPS validation
    print("Getting GPS coordinates...")
    local x, y, z = gps.locate(5)
    
    if not x then
        print("═══════════════════════════════════")
        print("ERROR: GPS signal not available!")
        print("═══════════════════════════════════")
        print("Cannot determine current position")
        print("")
        print("Solutions:")
        print("  1. Set up GPS satellites")
        print("  2. Move turtle closer to GPS")
        print("  3. Manually move turtle to home:")
        print(string.format("     %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Press ENTER to skip position check...")
        read()
    else
        local currentPos = {x=math.floor(x), y=math.floor(y), z=math.floor(z)}
        lastKnown = currentPos
        
        print(string.format("✓ GPS Position: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
        
        local atHome = (currentPos.x == homePos.x and 
                       currentPos.y == homePos.y and 
                       currentPos.z == homePos.z)
        
        if not atHome then
            local distance = math.abs(currentPos.x - homePos.x) + 
                           math.abs(currentPos.y - homePos.y) + 
                           math.abs(currentPos.z - homePos.z)
            
            print(string.format("⚠ Not at home! Distance: %d blocks", distance))
            print(string.format("  Current: %d, %d, %d", currentPos.x, currentPos.y, currentPos.z))
            print(string.format("  Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
            print("")
            print("AUTO-NAVIGATING back to home base...")
            print("(This may take a while)")
            print("")
            
            -- Auto-navigate to home
            moveAbs(homePos.x, homePos.y, homePos.z)
            
            print("✓ Arrived at home!")
        else
            print("✓ Turtle at home position")
        end
    end
    
    -- Verify chest is accessible
    print("Verifying chest...")
    
    -- Try all 4 directions to find chest
    local chestFound = false
    local chestDirection = nil
    
    for dir = 0, 3 do
        local ok, blockData = turtle.inspect()
        if ok and blockData and blockData.name then
            if string.find(blockData.name, "chest") then
                chestFound = true
                chestDirection = facing
                print(string.format("✓ Chest found at direction %d", facing))
                
                -- Update homeFacing to correct direction
                -- Turtle should face AWAY from chest
                homeFacing = (facing + 2) % 4
                facing = homeFacing
                
                -- Turn to face away from chest
                turtle.turnLeft()
                turtle.turnLeft()
                
                -- Save corrected facing
                saveHomeLocation(homePos, homeFacing)
                break
            end
        end
        
        -- Try next direction
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    if not chestFound then
        print("")
        print("═══════════════════════════════════")
        print("ERROR: Chest not found at home!")
        print("═══════════════════════════════════")
        print("Checked all 4 directions")
        print(string.format("Home: %d, %d, %d", homePos.x, homePos.y, homePos.z))
        print("")
        print("Please:")
        print("  1. Place chest next to turtle")
        print("  2. OR delete home_location.txt")
        print("  3. Then restart miner_v2")
        print("═══════════════════════════════════")
        error("Chest verification failed")
    end
    
    print("✓ Chest verified and direction corrected!")
    
    print("✓ Ready to mine!")
    print("")
end

-- Initial scan request
print("Requesting initial scan...")
requestScan()
sleep(2)

----------------------------------
-- COMMAND HANDLER
----------------------------------
local function checkCommands()
    -- Check for commands from computer (non-blocking)
    local senderId, message = rednet.receive(PROTOCOL, 0)
    if senderId and message then
        if message.type == "return_home" then
            print("")
            print("═══════════════════════════════════")
            print("*** RETURN HOME command received! ***")
            print("═══════════════════════════════════")
            
            -- Send acknowledgment
            rednet.send(COMPUTER_ID, {
                type = "status_update",
                status = "returning home",
                position = getPos()
            }, PROTOCOL)
            
            print("Returning to base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            
            -- Send arrived status
            rednet.send(COMPUTER_ID, {
                type = "status_update", 
                status = "at home",
                position = homePos
            }, PROTOCOL)
            
            print("✓ At home. Resuming in 5 seconds...")
            print("(Press Ctrl+T to stop)")
            print("═══════════════════════════════════")
            sleep(5)
            return true
        end
    end
    return false
end

local miningCycle = 0
local idleCount = 0

while true do
    -- Check for commands at start of cycle
    checkCommands()
    
    miningCycle = miningCycle + 1
    print(string.format("=== Cycle %d ===", miningCycle))
    
    -- Check inventory
    if inventoryAlmostFull() then
        print("Inventory full - returning home")
        moveAbs(homePos.x, homePos.y, homePos.z)
        depositToChest()
    end
    
    -- Check for commands after deposit
    checkCommands()
    
    -- Check fuel
    smartRefuel()
    
    -- Check for commands before requesting path
    checkCommands()
    
    -- Request path to next ore
    local steps, target = requestPath()
    
    if steps and target then
        idleCount = 0
        
        -- Execute path
        print(string.format("Target: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        local success = false
        local ok, err = pcall(function()
            success = executePathSteps(steps)
        end)
        
        if not ok then
            print("ERROR moving to ore:", err)
            print("Reporting ore as unreachable...")
            rednet.send(COMPUTER_ID, {
                type = "ore_failed",
                x = target.x,
                y = target.y,
                z = target.z
            }, PROTOCOL)
        elseif success then
            -- Check if we're actually at the ore location
            local pos = getPos()
            local dist = math.abs(pos.x - target.x) + math.abs(pos.y - target.y) + math.abs(pos.z - target.z)
            
            if dist <= 1 then
                -- We're close enough, mine it
                print("Mining ore...")
                turtle.dig()
                turtle.digDown()
                turtle.digUp()
                stats.oresMined = stats.oresMined + 1
                
                -- Report to computer
                reportOreMined(target)
                
                sleep(0.5)
            else
                print(string.format("Not close enough to ore (distance: %d)", dist))
                print("Reporting as unreachable...")
                rednet.send(COMPUTER_ID, {
                    type = "ore_failed",
                    x = target.x,
                    y = target.y,
                    z = target.z
                }, PROTOCOL)
            end
        end
        
        -- Check for commands after mining
        checkCommands()
    else
        -- No ores available
        idleCount = idleCount + 1
        print(string.format("Idle (no ores) - count: %d", idleCount))
        
        -- Check for commands during idle
        checkCommands()
        
        if idleCount >= 3 then
            print("Requesting new scan...")
            requestScan()
            idleCount = 0
        end
        
        -- Emergency: If scanner not responding, return home
        if idleCount >= 6 then
            print("WARNING: Scanner not responding!")
            print("Returning to home base...")
            moveAbs(homePos.x, homePos.y, homePos.z)
            depositToChest()
            print("At home. Waiting for scanner...")
            sleep(30)
            idleCount = 0
        end
        
        sleep(5)
    end
    
    -- Periodic refuel and smart checks
    smartRefuel()
end

----------------------------------
-- CLEANUP (unreachable but good practice)
----------------------------------
print("")
print("Returning home...")
moveAbs(homePos.x, homePos.y, homePos.z)
depositToChest()

print("")
print("═══════════════════════════════════")
print("  MINING COMPLETE")
print("═══════════════════════════════════")
print(string.format("Ores mined: %d", stats.oresMined))
print(string.format("Total moves: %d", stats.totalMoves))
print(string.format("Free moves: %d (%.1f%%)", 
    stats.freeMoves, (stats.freeMoves / math.max(1, stats.totalMoves) * 100)))
print("")
print(string.format("Blocks mined: %d", 
    stats.blocksMinedForward + stats.blocksMinedUp + stats.blocksMinedDown))
print(string.format("  Forward: %d", stats.blocksMinedForward))
print(string.format("  Up: %d", stats.blocksMinedUp))
print(string.format("  Down: %d", stats.blocksMinedDown))
print("")
print(string.format("Paths received: %d", stats.pathsReceived))
print(string.format("Scans requested: %d", stats.scansRequested))
print("═══════════════════════════════════")
