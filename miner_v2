-- SmartMiner Turtle (Works with Computer Brain)
-- Features: Request-based protocol, GPS positioning, smart pathfinding

----------------------------------
-- CONFIGURATION
----------------------------------
local PROTOCOL = "smartminer"
local COMPUTER_ID = 1               -- ID of the computer brain
local modemSide = "right"
local TURTLE_ID = os.getComputerID and os.getComputerID() or 2

----------------------------------
-- MOVEMENT STATISTICS
----------------------------------
local stats = {
    blocksMinedForward = 0,
    blocksMinedUp = 0,
    blocksMinedDown = 0,
    freeMoves = 0,
    totalMoves = 0,
    oresMined = 0,
    pathsReceived = 0,
    scansRequested = 0,
}

----------------------------------
-- WIRELESS MODEM SETUP
----------------------------------
local function findModem()
    for _, side in ipairs({"right", "left", "top", "bottom", "front", "back"}) do
        if peripheral.getType(side) and peripheral.getType(side):find("modem") then
            local m = peripheral.wrap(side)
            if m.isWireless and m.isWireless() then
                return side
            end
        end
    end
    return nil
end

local actualModemSide = findModem()
if not actualModemSide then
    error("ERROR: No wireless modem found on turtle!")
end

rednet.open(actualModemSide)
print("Wireless modem opened on:", actualModemSide)

----------------------------------
-- BASE STATION CHEST SETUP
----------------------------------
print("═══════════════════════════════════")
print("  CHEST SETUP  ")
print("═══════════════════════════════════")
print("Place chest BEHIND turtle")
print("(Turtle should face AWAY from chest)")
print("")
print("Press ENTER when ready...")
read()

-- Save home position
print("Getting home position...")
local homeX, homeY, homeZ = gps.locate(3)
if not homeX then
    error("ERROR: GPS signal required!")
end
homeX, homeY, homeZ = math.floor(homeX), math.floor(homeY), math.floor(homeZ)
print(string.format("✓ Home position: %d, %d, %d", homeX, homeY, homeZ))

-- Verify chest
print("Verifying chest...")
turtle.turnLeft()
turtle.turnLeft()

local ok, chestData = turtle.inspect()
if not ok or not string.find(chestData.name or "", "chest") then
    turtle.turnLeft()
    turtle.turnLeft()
    error("ERROR: No chest found behind turtle!")
end

print("✓ Chest detected!")
turtle.turnLeft()
turtle.turnLeft()

----------------------------------
-- GPS HELPERS
----------------------------------
local function gpsLoc()
    local x, y, z = gps.locate(3)
    if not x then 
        error("GPS signal lost!") 
    end
    return math.floor(x), math.floor(y), math.floor(z)
end

----------------------------------
-- DIRECTION CONTROL
----------------------------------
local function detectFacing()
    local x1, y1, z1 = gpsLoc()
    
    local moved = false
    for attempt = 1, 5 do
        if turtle.forward() then
            moved = true
            break
        end
        turtle.dig()
        turtle.attack()
        sleep(0.3)
    end
    
    if not moved then
        print("ERROR: Cannot move forward to detect facing!")
        return nil
    end
    
    local x2, y2, z2 = gpsLoc()
    
    local dx = x2 - x1
    local dz = z2 - z1
    
    local detectedFacing = nil
    if dz == -1 then detectedFacing = 0      -- North
    elseif dx == 1 then detectedFacing = 1   -- East
    elseif dz == 1 then detectedFacing = 2   -- South
    elseif dx == -1 then detectedFacing = 3  -- West
    end
    
    turtle.back()
    return detectedFacing
end

print("Detecting facing direction...")
local facing = detectFacing()
if not facing then
    error("ERROR: Could not detect facing direction!")
end

local dirNames = { [0]="north", [1]="east", [2]="south", [3]="west" }
print(string.format("✓ Turtle facing: %s", dirNames[facing]))

local homeFacing = facing
print(string.format("✓ Home facing saved: %s", dirNames[homeFacing]))
print("✓ Setup complete")
print("═══════════════════════════════════")

----------------------------------
-- SMART MOVEMENT
----------------------------------
local function tryForward()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.forward() then
        stats.freeMoves = stats.freeMoves + 1
        return true
    end
    
    while not turtle.forward() do
        if turtle.dig() then
            stats.blocksMinedForward = stats.blocksMinedForward + 1
        end
        turtle.attack()
        sleep(0.1)
    end
    return true
end

local function tryUp()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.up() then
        stats.freeMoves = stats.freeMoves + 1
        return true
    end
    
    while not turtle.up() do
        if turtle.digUp() then
            stats.blocksMinedUp = stats.blocksMinedUp + 1
        end
        turtle.attackUp()
        sleep(0.1)
    end
    return true
end

local function tryDown()
    stats.totalMoves = stats.totalMoves + 1
    
    if turtle.down() then
        stats.freeMoves = stats.freeMoves + 1
        return true
    end
    
    while not turtle.down() do
        if turtle.digDown() then
            stats.blocksMinedDown = stats.blocksMinedDown + 1
        end
        turtle.attackDown()
        sleep(0.1)
    end
    return true
end

local dirs = { north=0, east=1, south=2, west=3 }

local function turnTo(dir)
    local target = dirs[dir]
    while facing ~= target do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
end

----------------------------------
-- MOVING TO ABSOLUTE COORDINATE
----------------------------------
local function moveTo(tx, ty, tz)
    local x, y, z = gpsLoc()
    print(string.format("Moving: %d,%d,%d -> %d,%d,%d", x, y, z, tx, ty, tz))
    
    -- Vertical first
    local moveCount = 0
    while y < ty do
        tryUp()
        x, y, z = gpsLoc()
        moveCount = moveCount + 1
        if moveCount > 500 then 
            error("Stuck moving up!") 
        end
    end
    
    moveCount = 0
    while y > ty do
        tryDown()
        x, y, z = gpsLoc()
        moveCount = moveCount + 1
        if moveCount > 500 then 
            error("Stuck moving down!") 
        end
    end
    
    -- X axis
    if tx > x then turnTo("east") end
    if tx < x then turnTo("west") end
    moveCount = 0
    while x ~= tx do
        tryForward()
        x, y, z = gpsLoc()
        moveCount = moveCount + 1
        if moveCount > 500 then 
            error("Stuck on X axis!") 
        end
    end
    
    -- Z axis
    if tz > z then turnTo("south") end
    if tz < z then turnTo("north") end
    moveCount = 0
    while z ~= tz do
        tryForward()
        x, y, z = gpsLoc()
        moveCount = moveCount + 1
        if moveCount > 500 then 
            error("Stuck on Z axis!") 
        end
    end
    
    print(string.format("✓ Arrived at %d,%d,%d", x, y, z))
end

----------------------------------
-- FUEL MANAGEMENT
----------------------------------
local function invRefuel(amountNeeded)
    local startFuel = turtle.getFuelLevel()
    local targetFuel = startFuel + (amountNeeded or 1000)
    
    for slot = 1, 16 do
        if turtle.getFuelLevel() >= targetFuel then
            break
        end
        
        turtle.select(slot)
        if turtle.refuel(0) then
            local itemCount = turtle.getItemCount(slot)
            for i = 1, itemCount do
                if turtle.getFuelLevel() >= targetFuel then
                    break
                end
                turtle.refuel(1)
            end
        end
    end
    turtle.select(1)
    
    local gained = turtle.getFuelLevel() - startFuel
    if gained > 0 then
        print(string.format("Refueled: +%d fuel (now %d)", gained, turtle.getFuelLevel()))
    end
    return gained
end

local function smartRefuel()
    local current = turtle.getFuelLevel()
    local x, y, z = gpsLoc()
    
    local homeTrip = math.abs(homeX - x) + math.abs(homeY - y) + math.abs(homeZ - z)
    local buffer = 500
    local needed = homeTrip + buffer
    
    if current < needed then
        print(string.format("Low fuel! Current: %d, Need: %d", current, needed))
        invRefuel(needed - current + 200)
        return true
    end
    return false
end

----------------------------------
-- ITEM MANAGEMENT
----------------------------------
local KEEP_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod"
}

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function depositToChest()
    print("Depositing items to chest...")
    
    while facing ~= homeFacing do
        turtle.turnRight()
        facing = (facing + 1) % 4
    end
    
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    local deposited = 0
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item and not isFuelItem(item.name) then
            turtle.select(i)
            if turtle.drop() then
                deposited = deposited + 1
            end
        end
    end
    
    turtle.turnLeft()
    turtle.turnLeft()
    facing = (facing + 2) % 4
    
    smartRefuel()
    
    print(string.format("✓ Deposited %d stacks to chest", deposited))
    return deposited
end

local function inventoryAlmostFull()
    local emptySlots = 0
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            emptySlots = emptySlots + 1
        end
    end
    return emptySlots <= 3
end

----------------------------------
-- COMMUNICATION WITH COMPUTER
----------------------------------
local function sendRequest(msgType, data)
    data = data or {}
    data.type = msgType
    rednet.send(COMPUTER_ID, data, PROTOCOL)
end

local function waitForResponse(timeout)
    timeout = timeout or 10
    local senderId, message, protocol = rednet.receive(PROTOCOL, timeout)
    if senderId == COMPUTER_ID and message then
        return message
    end
    return nil
end

local function requestScan()
    print("Requesting scan from computer...")
    local x, y, z = gpsLoc()
    sendRequest("request_scan", {x=x, y=y, z=z})
    stats.scansRequested = stats.scansRequested + 1
    
    local response = waitForResponse(15)
    if response and response.type == "scan_result" then
        print(string.format("Scan complete: %d ores found", #response.ores))
        return response.ores
    end
    print("No scan response received")
    return nil
end

local function requestPath()
    print("Requesting path from computer...")
    local x, y, z = gpsLoc()
    sendRequest("request_path", {x=x, y=y, z=z})
    
    local response = waitForResponse(10)
    if response and response.type == "path" then
        stats.pathsReceived = stats.pathsReceived + 1
        if #response.steps > 0 then
            print(string.format("Path received: %d steps to %s", 
                #response.steps, response.target.name))
            return response.steps, response.target
        else
            print("No path available (no ores)")
            return nil, nil
        end
    end
    print("No path response received")
    return nil, nil
end

local function reportOreMined(target)
    print(string.format("Reporting mined ore at %d,%d,%d", target.x, target.y, target.z))
    sendRequest("ore_mined", {x=target.x, y=target.y, z=target.z})
    
    local response = waitForResponse(5)
    if response and response.type == "ack" then
        print(string.format("Computer acknowledged. %d ores remaining", response.remaining))
        return true
    end
    return false
end

----------------------------------
-- PATH EXECUTION
----------------------------------
local function executePathSteps(steps)
    if not steps or #steps == 0 then 
        return false 
    end
    
    print(string.format("Executing path with %d steps", #steps))
    
    for i, step in ipairs(steps) do
        if i % 10 == 0 then
            print(string.format("  Step %d/%d", i, #steps))
        end
        
        moveTo(step.x, step.y, step.z)
        
        -- Check fuel periodically
        if i % 20 == 0 then
            smartRefuel()
        end
    end
    
    print("Path execution complete")
    return true
end

----------------------------------
-- MAIN MINING LOOP
----------------------------------
print("═══════════════════════════════════")
print("  SMARTMINER TURTLE STARTED")
print("═══════════════════════════════════")
print("Turtle ID:", TURTLE_ID)
print("Computer ID:", COMPUTER_ID)
print("Protocol:", PROTOCOL)
print("Home:", homeX, homeY, homeZ)
print("")

-- Initial scan request
requestScan()

print("Starting mining loop...")
print("Press Ctrl+T to stop")
print("")

local miningCycle = 0
local idleTime = 0

while true do
    miningCycle = miningCycle + 1
    print(string.format("=== Mining Cycle %d ===", miningCycle))
    
    -- Check inventory
    if inventoryAlmostFull() then
        print("Inventory full, returning home...")
        moveTo(homeX, homeY, homeZ)
        depositToChest()
    end
    
    -- Request path to next ore
    local steps, target = requestPath()
    
    if steps and target then
        idleTime = 0
        
        -- Execute path
        local success = executePathSteps(steps)
        
        if success then
            -- Mine the ore
            print("Mining ore...")
            turtle.dig()
            turtle.digUp()
            turtle.digDown()
            stats.oresMined = stats.oresMined + 1
            
            -- Report to computer
            reportOreMined(target)
            
            -- Brief pause
            sleep(0.5)
        end
    else
        -- No ores available
        idleTime = idleTime + 1
        print(string.format("No ores available (idle: %d)", idleTime))
        
        if idleTime >= 3 then
            -- Request new scan after being idle
            print("Requesting new scan...")
            requestScan()
            idleTime = 0
        end
        
        sleep(5)
    end
    
    -- Periodic refuel check
    smartRefuel()
end

----------------------------------
-- CLEANUP (if loop breaks)
----------------------------------
print("")
print("Returning to home...")
moveTo(homeX, homeY, homeZ)
depositToChest()

print("")
print("═══════════════════════════════════")
print("  MINING STATISTICS")
print("═══════════════════════════════════")
print(string.format("Ores mined: %d", stats.oresMined))
print(string.format("Total moves: %d", stats.totalMoves))
print(string.format("Free moves: %d (%.1f%%)", 
    stats.freeMoves, (stats.freeMoves / math.max(1, stats.totalMoves) * 100)))
print("")
print("Blocks mined for movement:")
print(string.format("  Forward: %d", stats.blocksMinedForward))
print(string.format("  Up: %d", stats.blocksMinedUp))
print(string.format("  Down: %d", stats.blocksMinedDown))
local totalBlocksMined = stats.blocksMinedForward + stats.blocksMinedUp + stats.blocksMinedDown
print(string.format("  Total: %d", totalBlocksMined))
print("")
print(string.format("Scans requested: %d", stats.scansRequested))
print(string.format("Paths received: %d", stats.pathsReceived))
print("═══════════════════════════════════")
