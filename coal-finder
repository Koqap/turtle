-- COAL FINDER - Auto Coal Detection & Mining (v2.0)
-- FEATURES:
--  * Auto-detects advanced scanner peripherals (Plethora, etc)
--  * Long-range detection (8-10 blocks with mods)
--  * Fast vanilla fallback (efficient adjacent scanning)
--  * Mines only coal, no tunnel digging
--  * Returns to chest when inventory full
--  * Smart pathfinding to detected ores
--  * Position tracking for navigation back

-- ============ CONFIG ==============
local SCAN_RADIUS = 10           -- How far to search (with advanced scanner)
local VANILLA_RANGE = 3          -- Search range for vanilla mode
local MIN_FUEL = 100             -- Minimum fuel before returning
local MOVE_INTERVAL = 3          -- Blocks between scan points (vanilla mode)

-- Items to look for
local TARGET_ORES = {
    "minecraft:coal_ore",
    "minecraft:deepslate_coal_ore",
}

-- Items to KEEP
local KEEP_ITEMS = {
    "minecraft:coal_ore", "minecraft:deepslate_coal_ore",
    "minecraft:coal", "minecraft:charcoal",
    "minecraft:cobblestone", "minecraft:cobbled_deepslate",
    "minecraft:deepslate", "minecraft:stone",
}

local FUEL_ITEMS = {
    "minecraft:coal", "minecraft:charcoal", "minecraft:coal_block",
    "minecraft:lava_bucket", "minecraft:blaze_rod",
}

-- ============ STATE ==============
local chestPos = {x=0, y=0, z=0, facing=0}
local currentPos = {x=0, y=0, z=0, facing=0}
local stats = {
    coalFound = 0,
    blocksMined = 0,
    returns = 0,
}

-- Advanced scanner detection
local scanner = nil
local scannerType = "vanilla"

-- Try to find advanced scanning peripherals
local function detectScanner()
    -- Try Plethora's block scanner
    if peripheral then
        scanner = peripheral.find("geoScanner")
        if scanner then
            scannerType = "plethora"
            print("âœ“ Plethora GeoScanner detected!")
            return true
        end

        -- Try other scanner types
        scanner = peripheral.find("blockScanner")
        if scanner then
            scannerType = "advanced"
            print("âœ“ Advanced BlockScanner detected!")
            return true
        end
    end

    print("â†’ Using vanilla detection mode")
    scannerType = "vanilla"
    return false
end

-- ============ POSITION TRACKING ==============
local function updatePosition(movement)
    if movement == "forward" then
        if currentPos.facing == 0 then currentPos.z = currentPos.z - 1
        elseif currentPos.facing == 1 then currentPos.x = currentPos.x + 1
        elseif currentPos.facing == 2 then currentPos.z = currentPos.z + 1
        else currentPos.x = currentPos.x - 1 end
    elseif movement == "back" then
        if currentPos.facing == 0 then currentPos.z = currentPos.z + 1
        elseif currentPos.facing == 1 then currentPos.x = currentPos.x - 1
        elseif currentPos.facing == 2 then currentPos.z = currentPos.z - 1
        else currentPos.x = currentPos.x + 1 end
    elseif movement == "up" then
        currentPos.y = currentPos.y + 1
    elseif movement == "down" then
        currentPos.y = currentPos.y - 1
    elseif movement == "turnLeft" then
        currentPos.facing = (currentPos.facing - 1) % 4
    elseif movement == "turnRight" then
        currentPos.facing = (currentPos.facing + 1) % 4
    end
end

local function calculatePathToChest()
    local dx = chestPos.x - currentPos.x
    local dy = chestPos.y - currentPos.y
    local dz = chestPos.z - currentPos.z
    return dx, dy, dz
end

-- ============ UTILITIES ==============
local function isTargetOre(blockName)
    if not blockName then return false end
    for _, name in ipairs(TARGET_ORES) do
        if name == blockName then return true end
    end
    return false
end

local function isKeepItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(KEEP_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function isFuelItem(itemName)
    if not itemName then return false end
    for _, name in ipairs(FUEL_ITEMS) do
        if name == itemName then return true end
    end
    return false
end

local function inventoryFull()
    for i=1,16 do
        if turtle.getItemCount(i) == 0 then return false end
    end
    return true
end

local function calculateFuelNeeded()
    local dx, dy, dz = calculatePathToChest()
    return math.abs(dx) + math.abs(dy) + math.abs(dz) + 50
end

-- ============ MOVEMENT ==============
local function safeForward()
    for attempt=1,3 do
        if turtle.forward() then
            updatePosition("forward")
            return true
        else
            -- Check if it's something we want to mine
            local ok, data = turtle.inspect()
            if ok and isTargetOre(data.name) then
                print("  â› Mining: " .. data.name)
                turtle.dig()
                stats.coalFound = stats.coalFound + 1
                stats.blocksMined = stats.blocksMined + 1
            else
                turtle.dig()
                stats.blocksMined = stats.blocksMined + 1
            end
            turtle.attack()
            sleep(0.1)
        end
    end
    return false
end

local function safeUp()
    for attempt=1,3 do
        if turtle.up() then
            updatePosition("up")
            return true
        else
            local ok, data = turtle.inspectUp()
            if ok and isTargetOre(data.name) then
                print("  â› Mining: " .. data.name)
                turtle.digUp()
                stats.coalFound = stats.coalFound + 1
                stats.blocksMined = stats.blocksMined + 1
            else
                turtle.digUp()
                stats.blocksMined = stats.blocksMined + 1
            end
            sleep(0.1)
        end
    end
    return false
end

local function safeDown()
    for attempt=1,3 do
        if turtle.down() then
            updatePosition("down")
            return true
        else
            local ok, data = turtle.inspectDown()
            if ok and isTargetOre(data.name) then
                print("  â› Mining: " .. data.name)
                turtle.digDown()
                stats.coalFound = stats.coalFound + 1
                stats.blocksMined = stats.blocksMined + 1
            else
                turtle.digDown()
                stats.blocksMined = stats.blocksMined + 1
            end
            sleep(0.1)
        end
    end
    return false
end

local function turnLeft()
    turtle.turnLeft()
    updatePosition("turnLeft")
end

local function turnRight()
    turtle.turnRight()
    updatePosition("turnRight")
end

-- ============ NAVIGATION ==============
local function navigateToChest()
    local dx, dy, dz = calculatePathToChest()

    -- Move Y first
    while dy > 0 do
        if turtle.up() then updatePosition("up"); dy = dy - 1
        else turtle.digUp(); sleep(0.2) end
    end
    while dy < 0 do
        if turtle.down() then updatePosition("down"); dy = dy + 1
        else turtle.digDown(); sleep(0.2) end
    end

    -- Move X
    if dx ~= 0 then
        local targetFacing = dx > 0 and 1 or 3
        while currentPos.facing ~= targetFacing do
            turnRight()
        end
        for i = 1, math.abs(dx) do
            while not turtle.forward() do
                turtle.dig(); turtle.attack(); sleep(0.2)
            end
            updatePosition("forward")
        end
    end

    -- Move Z
    if dz ~= 0 then
        local targetFacing = dz > 0 and 2 or 0
        while currentPos.facing ~= targetFacing do
            turnRight()
        end
        for i = 1, math.abs(dz) do
            while not turtle.forward() do
                turtle.dig(); turtle.attack(); sleep(0.2)
            end
            updatePosition("forward")
        end
    end

    -- Face chest
    while currentPos.facing ~= chestPos.facing do
        turnRight()
    end
end

-- ============ CHEST OPERATIONS ==============
local function depositItemsToChest()
    turtle.turnLeft(); turtle.turnLeft()
    local deposited = 0
    for i=1,16 do
        local item = turtle.getItemDetail(i)
        if item then
            if not isKeepItem(item.name) and not isFuelItem(item.name) then
                turtle.select(i)
                turtle.drop()
                deposited = deposited + item.count
            end
        end
    end
    turtle.turnLeft(); turtle.turnLeft()
    return deposited
end

local function takeFuelFromChest()
    turtle.turnLeft(); turtle.turnLeft()
    local fuelTaken = 0
    for slot=1,16 do
        if turtle.getItemCount(slot) == 0 then
            turtle.select(slot)
            turtle.suck(64)
            local item = turtle.getItemDetail(slot)
            if item then
                if isFuelItem(item.name) then
                    fuelTaken = fuelTaken + item.count
                else
                    turtle.drop()
                end
            end
        end
    end
    turtle.turnLeft(); turtle.turnLeft()
    return fuelTaken
end

local function doAutoRefuel()
    local fuelBefore = turtle.getFuelLevel()
    for i=1,16 do
        local item = turtle.getItemDetail(i)
        if item and isFuelItem(item.name) then
            turtle.select(i)
            turtle.refuel()
        end
    end
    return turtle.getFuelLevel() - fuelBefore
end

local function returnToChestAndRefuel()
    print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("â•‘  RETURNING TO CHEST                    â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

    local resumeX, resumeY, resumeZ = currentPos.x, currentPos.y, currentPos.z
    local resumeFacing = currentPos.facing

    print("â†’ Navigating to chest...")
    navigateToChest()

    print("â†’ Depositing items...")
    local deposited = depositItemsToChest()
    print(string.format("  âœ“ Deposited %d items", deposited))

    print("â†’ Taking fuel...")
    local fuelTaken = takeFuelFromChest()
    print(string.format("  âœ“ Got %d fuel items", fuelTaken))

    print("â†’ Refueling...")
    doAutoRefuel()
    print(string.format("  âœ“ Fuel: %d", turtle.getFuelLevel()))

    stats.returns = stats.returns + 1

    print(string.format("\nâœ“ Stats - Coal: %d | Mined: %d | Returns: %d\n",
        stats.coalFound, stats.blocksMined, stats.returns))

    return resumeX, resumeY, resumeZ, resumeFacing
end

-- ============ ADVANCED SCANNING ==============
local function scanWithAdvancedScanner()
    -- Scan large area with advanced scanner (Plethora, etc)
    local ores = {}

    if scannerType == "plethora" and scanner and scanner.scan then
        local blocks = scanner.scan(SCAN_RADIUS)
        for _, block in ipairs(blocks) do
            if isTargetOre(block.name) then
                table.insert(ores, {
                    x = currentPos.x + block.x,
                    y = currentPos.y + block.y,
                    z = currentPos.z + block.z,
                    name = block.name
                })
            end
        end
    end

    return ores
end

-- ============ VANILLA SCANNING (OPTIMIZED) ==============
local function scanDirection(direction)
    local ok, data
    if direction == "forward" then
        ok, data = turtle.inspect()
    elseif direction == "up" then
        ok, data = turtle.inspectUp()
    elseif direction == "down" then
        ok, data = turtle.inspectDown()
    end

    if ok and isTargetOre(data.name) then
        return true, data.name
    end
    return false, nil
end

local function quickScanNearby()
    -- Fast scan of adjacent blocks only
    local coals = {}

    -- Check forward
    local ok, data = turtle.inspect()
    if ok and isTargetOre(data.name) then
        table.insert(coals, {dir="forward", name=data.name, x=currentPos.x, y=currentPos.y, z=currentPos.z})
    end

    -- Check up
    ok, data = turtle.inspectUp()
    if ok and isTargetOre(data.name) then
        table.insert(coals, {dir="up", name=data.name, x=currentPos.x, y=currentPos.y+1, z=currentPos.z})
    end

    -- Check down
    ok, data = turtle.inspectDown()
    if ok and isTargetOre(data.name) then
        table.insert(coals, {dir="down", name=data.name, x=currentPos.x, y=currentPos.y-1, z=currentPos.z})
    end

    return coals
end

local function mineCoalVein()
    -- Mine all coal blocks around current position
    local mined = 0

    -- Check and mine forward
    local ok, data = turtle.inspect()
    if ok and isTargetOre(data.name) then
        turtle.dig()
        mined = mined + 1
    end

    -- Check and mine up
    ok, data = turtle.inspectUp()
    if ok and isTargetOre(data.name) then
        turtle.digUp()
        mined = mined + 1
    end

    -- Check and mine down
    ok, data = turtle.inspectDown()
    if ok and isTargetOre(data.name) then
        turtle.digDown()
        mined = mined + 1
    end

    -- Check all 4 horizontal directions
    for i=1,4 do
        ok, data = turtle.inspect()
        if ok and isTargetOre(data.name) then
            turtle.dig()
            mined = mined + 1
        end
        turnRight()
    end

    return mined
end

-- ============ FAST GRID SEARCH ==============
local function navigateToTarget(tx, ty, tz)
    -- Navigate to specific coordinates
    local dx = tx - currentPos.x
    local dy = ty - currentPos.y
    local dz = tz - currentPos.z

    -- Move Y first
    while dy > 0 do
        safeUp()
        dy = dy - 1
    end
    while dy < 0 do
        safeDown()
        dy = dy + 1
    end

    -- Move X
    if dx ~= 0 then
        local targetFacing = dx > 0 and 1 or 3
        while currentPos.facing ~= targetFacing do turnRight() end
        for i = 1, math.abs(dx) do
            safeForward()
        end
    end

    -- Move Z
    if dz ~= 0 then
        local targetFacing = dz > 0 and 2 or 0
        while currentPos.facing ~= targetFacing do turnRight() end
        for i = 1, math.abs(dz) do
            safeForward()
        end
    end
end

local function fastGridSearch()
    print("\nâ†’ Fast grid search mode")

    if scannerType == "plethora" or scannerType == "advanced" then
        -- Advanced scanner mode - scan from fixed positions
        print("  Using advanced scanner...")

        while true do
            -- Scan large area
            local ores = scanWithAdvancedScanner()

            if #ores > 0 then
                print(string.format("  âœ“ Found %d coal ore(s)!", #ores))

                -- Mine each detected ore
                for _, ore in ipairs(ores) do
                    -- Check inventory/fuel
                    if inventoryFull() or turtle.getFuelLevel() < calculateFuelNeeded() + MIN_FUEL then
                        returnToChestAndRefuel()
                    end

                    -- Navigate to ore
                    print(string.format("  â†’ Mining at (%d,%d,%d)", ore.x, ore.y, ore.z))
                    navigateToTarget(ore.x, ore.y, ore.z)

                    -- Mine the vein
                    local mined = mineCoalVein()
                    stats.coalFound = stats.coalFound + mined
                end
            else
                print("  No more coal in range")
                break
            end
        end
    else
        -- Vanilla mode - faster grid pattern
        print("  Using vanilla grid search...")
        local range = VANILLA_RANGE

        for x = -range, range, MOVE_INTERVAL do
            for z = -range, range, MOVE_INTERVAL do
                -- Check inventory/fuel
                if inventoryFull() or turtle.getFuelLevel() < calculateFuelNeeded() + MIN_FUEL then
                    returnToChestAndRefuel()
                end

                -- Move to grid position
                navigateToTarget(x, currentPos.y, z)

                -- Quick scan nearby
                local coals = quickScanNearby()
                if #coals > 0 then
                    print(string.format("  âœ“ Coal nearby at (%d,%d,%d)!", x, currentPos.y, z))
                    local mined = mineCoalVein()
                    stats.coalFound = stats.coalFound + mined
                end
            end
        end
    end

    return true
end

-- ============ INITIALIZATION ==============
local function initialChecks()
    if not turtle.getItemDetail then
        print("ERROR: Requires Mining Turtle")
        return false
    end

    turtle.turnLeft(); turtle.turnLeft()
    local ok, data = turtle.inspect()

    if not ok or not string.find(data.name or "", "chest") then
        turtle.turnLeft(); turtle.turnLeft()
        print("ERROR: Place chest BEHIND turtle")
        return false
    end

    turtle.turnLeft(); turtle.turnLeft()
    chestPos = {x=0, y=0, z=0, facing=0}

    print(string.format("âœ“ Chest detected at home position"))

    -- Detect scanner
    detectScanner()

    takeFuelFromChest()
    doAutoRefuel()

    return true
end

-- ============ MAIN ==============
print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
print("â•‘  COAL FINDER v2.0 - FAST MODE          â•‘")
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("Mode: OPTIMIZED COAL DETECTION")
print("Features:")
print("  â€¢ Auto-detects advanced scanners")
print("  â€¢ Long-range detection (with mods)")
print("  â€¢ Fast grid search pattern")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

if not initialChecks() then return end

if scannerType == "plethora" or scannerType == "advanced" then
    print(string.format("Scan radius: %d blocks (advanced)", SCAN_RADIUS))
else
    print(string.format("Scan range: %d blocks (vanilla)", VANILLA_RANGE))
    print(string.format("Grid interval: %d blocks", MOVE_INTERVAL))
end

print("\nğŸ” Starting fast coal search...\n")

-- Run fast grid search
fastGridSearch()

-- Return home
print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
print("â•‘  SEARCH COMPLETE!                      â•‘")
print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print(string.format("Coal found: %d", stats.coalFound))
print(string.format("Blocks mined: %d", stats.blocksMined))
print(string.format("Returns: %d", stats.returns))
print("\nReturning to home...")
if currentPos.x ~= 0 or currentPos.y ~= 0 or currentPos.z ~= 0 then
    navigateToChest()
    depositItemsToChest()
end
print("âœ“ Done!")
