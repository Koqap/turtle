-- SmartMiner Computer Brain (Advanced Computer + Geo Scanner + Basalt GUI)
-- Features: A* pathfinding, disk drive persistence, real-time GUI, request-response protocol

----------------------------------
-- CONFIGURATION
----------------------------------
local scannerSide = "right"          -- side where geo scanner is attached
local modemSide = "left"             -- side where wireless modem is attached
local BASALT = true                  -- set true if Basalt installed (v2 API)
local SCAN_RADIUS = 8                -- scanner radius
local AUTO_SAVE_INTERVAL = 30        -- seconds
local PROTOCOL = "smartminer"        -- rednet protocol

-- IDs and networking
local COMPUTER_ID = os.getComputerID and os.getComputerID() or 1
local TURTLE_TIMEOUT = 5

----------------------------------
-- PERIPHERALS SETUP
----------------------------------
local scanner = peripheral.wrap(scannerSide)
local modem = peripheral.wrap(modemSide)

-- Disk drive storage instead of memory card
local drive = peripheral.find("drive")

if not scanner then
    print("WARNING: Geo scanner not found on " .. scannerSide)
end

-- Ensure rednet open
if modem and peripheral.getType(modemSide):find("modem") then
    rednet.open(modemSide)
else
    print("Warning: modem not found on " .. modemSide)
end

----------------------------------
-- MAP DATA STRUCTURE
----------------------------------
local mapData = {
    visited = {},       -- ["x,y,z"] = true
    blocks = {},        -- ["x,y,z"] = blockName
    ores = {},          -- list of {x,y,z,name,claimed=false}
    home = {x=0,y=0,z=0},
}

----------------------------------
-- HELPERS
----------------------------------
local function keyFrom(x,y,z) 
    return x..","..y..","..z 
end

local function getDiskPath()
    if drive and drive.isDiskPresent() then 
        return drive.getMountPath() 
    end
    return nil
end

local function saveMap()
    local path = getDiskPath()
    if not path then 
        print("No disk present for saving")
        return 
    end
    local f = fs.open(path.."/minerMap.txt", "w")
    if f then 
        f.write(textutils.serialize(mapData))
        f.close()
        print("Map saved to disk")
    end
end

local function loadMap()
    local path = getDiskPath()
    if not path then 
        print("No disk present for loading")
        return 
    end
    if fs.exists(path.."/minerMap.txt") then
        local f = fs.open(path.."/minerMap.txt", "r")
        if f then 
            local data = f.readAll()
            f.close()
            local ok, dat = pcall(function() return textutils.unserialize(data) end)
            if ok and type(dat) == "table" then 
                mapData = dat 
                print("Map loaded from disk")
            end
        end
    end
end

-- Load map on startup
loadMap()

----------------------------------
-- SCANNER WRAPPER
----------------------------------
local function doScan(radius)
    if not scanner or not scanner.scan then 
        print("No scanner available!")
        return {} 
    end
    local ok, res = pcall(function() return scanner.scan(radius) end)
    if not ok or not res then 
        print("Scan failed:", res)
        return {} 
    end
    return res
end

-- Ore definitions (supports both normal and deepslate)
local ORE_NAMES = {
    ["minecraft:iron_ore"] = true,
    ["minecraft:deepslate_iron_ore"] = true,
    ["minecraft:coal_ore"] = true,
    ["minecraft:deepslate_coal_ore"] = true,
    ["minecraft:gold_ore"] = true,
    ["minecraft:deepslate_gold_ore"] = true,
    ["minecraft:diamond_ore"] = true,
    ["minecraft:deepslate_diamond_ore"] = true,
    ["minecraft:emerald_ore"] = true,
    ["minecraft:deepslate_emerald_ore"] = true,
    ["minecraft:redstone_ore"] = true,
    ["minecraft:deepslate_redstone_ore"] = true,
    ["minecraft:lapis_ore"] = true,
    ["minecraft:deepslate_lapis_ore"] = true,
    ["minecraft:copper_ore"] = true,
    ["minecraft:deepslate_copper_ore"] = true,
}

local function addOresFromScan(scanList, scanX, scanY, scanZ)
    scanX = scanX or 0
    scanY = scanY or 0
    scanZ = scanZ or 0
    
    for _, b in ipairs(scanList) do
        -- Convert to absolute coordinates
        local absX, absY, absZ = scanX + b.x, scanY + b.y, scanZ + b.z
        
        -- Store block info
        mapData.blocks[keyFrom(absX, absY, absZ)] = b.name
        
        -- Add ores
        if ORE_NAMES[b.name] then
            local k = keyFrom(absX, absY, absZ)
            local exists = false
            for _, o in ipairs(mapData.ores) do 
                if o.x == absX and o.y == absY and o.z == absZ then 
                    exists = true
                    break 
                end 
            end
            if not exists then
                table.insert(mapData.ores, {
                    x = absX, 
                    y = absY, 
                    z = absZ, 
                    name = b.name, 
                    claimed = false
                })
            end
        end
    end
    saveMap()
end

----------------------------------
-- A* PATHFINDER (3D)
----------------------------------
local function neighbors(node)
    local x, y, z = node.x, node.y, node.z
    return {
        {x=x+1, y=y, z=z, dir="east"},
        {x=x-1, y=y, z=z, dir="west"},
        {x=x, y=y+1, z=z, dir="up"},
        {x=x, y=y-1, z=z, dir="down"},
        {x=x, y=y, z=z+1, dir="south"},
        {x=x, y=y, z=z-1, dir="north"},
    }
end

local function isBlocked(x, y, z)
    local name = mapData.blocks[keyFrom(x, y, z)]
    if not name then return false end
    -- treat known liquids/bedrock as blocked
    if name:find("lava") or name:find("water") or name == "minecraft:bedrock" then 
        return true 
    end
    return false
end

local function heuristic(a, b)
    return math.abs(a.x - b.x) + math.abs(a.y - b.y) + math.abs(a.z - b.z)
end

local function computePath(start, goal)
    local open = {}
    local openMap = {}
    local cameFrom = {}
    local gScore = {}
    local fScore = {}
    
    local function push(node)
        table.insert(open, node)
        openMap[keyFrom(node.x, node.y, node.z)] = true
    end
    
    local function popLowest()
        local bestIdx, bestF = 1, math.huge
        for i, node in ipairs(open) do
            local k = keyFrom(node.x, node.y, node.z)
            if fScore[k] and fScore[k] < bestF then 
                bestF = fScore[k]
                bestIdx = i 
            end
        end
        local node = table.remove(open, bestIdx)
        if node then 
            openMap[keyFrom(node.x, node.y, node.z)] = nil 
        end
        return node
    end
    
    local startKey = keyFrom(start.x, start.y, start.z)
    gScore[startKey] = 0
    fScore[startKey] = heuristic(start, goal)
    push({x=start.x, y=start.y, z=start.z})

    local iterations = 0
    local maxIterations = 10000
    
    while #open > 0 and iterations < maxIterations do
        iterations = iterations + 1
        local current = popLowest()
        
        if current.x == goal.x and current.y == goal.y and current.z == goal.z then
            -- reconstruct path
            local path = {}
            local curKey = keyFrom(current.x, current.y, current.z)
            while curKey do
                table.insert(path, 1, {x=current.x, y=current.y, z=current.z})
                local c = cameFrom[curKey]
                if not c then break end
                current = c
                curKey = keyFrom(current.x, current.y, current.z)
            end
            return path
        end
        
        for _, n in ipairs(neighbors(current)) do
            if not isBlocked(n.x, n.y, n.z) then
                local nk = keyFrom(n.x, n.y, n.z)
                local currentKey = keyFrom(current.x, current.y, current.z)
                local tentative = gScore[currentKey] + 1
                
                if not gScore[nk] or tentative < gScore[nk] then
                    cameFrom[nk] = current
                    gScore[nk] = tentative
                    fScore[nk] = tentative + heuristic(n, goal)
                    if not openMap[nk] then 
                        push({x=n.x, y=n.y, z=n.z}) 
                    end
                end
            end
        end
    end
    
    return nil -- no path found
end

----------------------------------
-- MESSAGE PROTOCOL HANDLERS
----------------------------------
local function handleRequest(id, msg)
    if type(msg) ~= "table" or not msg.type then 
        return 
    end

    if msg.type == "request_scan" then
        print(string.format("[%s] Scan request from turtle %d", os.time(), id))
        local scanX, scanY, scanZ = msg.x or 0, msg.y or 0, msg.z or 0
        local scan = doScan(SCAN_RADIUS)
        addOresFromScan(scan, scanX, scanY, scanZ)
        rednet.send(id, { 
            type = "scan_result", 
            ores = mapData.ores,
            scanned = #scan 
        }, PROTOCOL)
        print(string.format("  Sent %d ores to turtle", #mapData.ores))

    elseif msg.type == "request_path" then
        print(string.format("[%s] Path request from turtle %d", os.time(), id))
        local cx, cy, cz = msg.x, msg.y, msg.z
        print(string.format("  Turtle at: %d,%d,%d", cx, cy, cz))
        
        -- choose nearest unclaimed ore
        local bestIdx, bestDist = nil, math.huge
        for i, o in ipairs(mapData.ores) do
            if not o.claimed and not mapData.visited[keyFrom(o.x, o.y, o.z)] then
                local dx = o.x - cx
                local dy = o.y - cy
                local dz = o.z - cz
                local dist = math.abs(dx) + math.abs(dy) + math.abs(dz)
                if dist < bestDist then 
                    bestDist = dist
                    bestIdx = i 
                end
            end
        end
        
        if not bestIdx then
            print("  No available ores")
            rednet.send(id, { 
                type = "path", 
                steps = {} 
            }, PROTOCOL)
            return
        end
        
        -- mark claimed to avoid races
        mapData.ores[bestIdx].claimed = true
        saveMap()

        local target = mapData.ores[bestIdx]
        print(string.format("  Target ore: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        -- compute path with A*
        local path = nil
        local ok, res = pcall(function() 
            return computePath(
                {x=cx, y=cy, z=cz}, 
                {x=target.x, y=target.y, z=target.z}
            ) 
        end)
        
        if ok and res then
            path = res
            print(string.format("  Path found: %d steps", #path))
        else
            path = {}
            print("  Path computation failed:", res)
        end
        
        rednet.send(id, { 
            type = "path", 
            steps = path, 
            target = target 
        }, PROTOCOL)

    elseif msg.type == "ore_mined" then
        print(string.format("[%s] Ore mined report from turtle %d", os.time(), id))
        local ox, oy, oz = msg.x, msg.y, msg.z
        mapData.visited[keyFrom(ox, oy, oz)] = true
        
        -- remove ore from list
        for i, o in ipairs(mapData.ores) do
            if o.x == ox and o.y == oy and o.z == oz then 
                print(string.format("  Removed ore: %s at %d,%d,%d", o.name, ox, oy, oz))
                table.remove(mapData.ores, i)
                break 
            end
        end
        saveMap()
        
        -- Send acknowledgment
        rednet.send(id, {
            type = "ack",
            remaining = #mapData.ores
        }, PROTOCOL)
    end
end

----------------------------------
-- BASALT GUI v2 API
----------------------------------
if BASALT then
    print("Initializing Basalt GUI (v2)...")
    local ok, basalt = pcall(require, "basalt")
    
    if not ok then
        print("Basalt not available, using text mode")
        BASALT = false
    else
        -- Create main frame
        local main = basalt.createFrame()
        
        local mapW, mapH = 45, 18
        
        -- Title
        local title = main:addLabel()
        title:setPosition(1, 1)
        title:setSize(mapW + 25, 1)
        title:setText("SMARTMINER COMPUTER BRAIN")
        title:setBackground(colors.blue)
        title:setForeground(colors.white)
        
        -- Map display (left side)
        local mapBox = main:addTextfield()
        mapBox:setPosition(1, 2)
        mapBox:setSize(mapW, mapH)
        mapBox:setBackground(colors.black)
        mapBox:setForeground(colors.white)
        
        -- Info panel (right side)
        local infoBox = main:addTextfield()
        infoBox:setPosition(mapW + 2, 2)
        infoBox:setSize(23, mapH)
        infoBox:setBackground(colors.gray)
        infoBox:setForeground(colors.white)
        
        -- Status bar
        local statusBar = main:addLabel()
        statusBar:setPosition(1, mapH + 2)
        statusBar:setSize(mapW + 25, 1)
        statusBar:setBackground(colors.black)
        statusBar:setForeground(colors.yellow)
        
        -- Log area
        local logBox = main:addTextfield()
        logBox:setPosition(1, mapH + 3)
        logBox:setSize(mapW + 25, 7)
        logBox:setBackground(colors.black)
        logBox:setForeground(colors.lightGray)
        
        local logBuffer = {}
        local maxLogLines = 6
        
        local function addLog(text)
            table.insert(logBuffer, text)
            if #logBuffer > maxLogLines then
                table.remove(logBuffer, 1)
            end
            logBox:setText(table.concat(logBuffer, "\n"))
        end
        
        -- Render function
        local function updateDisplay()
            -- Map rendering
            local cx, cy, cz = mapData.home.x, mapData.home.y, mapData.home.z
            local rangeX = math.floor(mapW / 2)
            local rangeZ = math.floor(mapH / 2)
            local out = {}
            
            for z = -rangeZ, rangeZ do
                local row = ""
                for x = -rangeX, rangeX do
                    local wx = cx + x
                    local wz = cz + z
                    local k = keyFrom(wx, cy, wz)
                    
                    if x == 0 and z == 0 then
                        row = row .. "H"
                    elseif mapData.visited[k] then
                        row = row .. "."
                    else
                        local hasOre = false
                        for _, o in ipairs(mapData.ores) do
                            if o.x == wx and o.z == wz then
                                hasOre = true
                                break
                            end
                        end
                        if hasOre then
                            row = row .. "*"
                        elseif mapData.blocks[k] then
                            row = row .. "#"
                        else
                            row = row .. " "
                        end
                    end
                end
                table.insert(out, row)
            end
            mapBox:setText(table.concat(out, "\n"))
            
            -- Info panel
            local infoText = string.format(
                "ORES: %d\n" ..
                "VISITED: %d\n" ..
                "%s\n" ..
                "Recent Ores:\n",
                #mapData.ores,
                (function()
                    local count = 0
                    for _ in pairs(mapData.visited) do count = count + 1 end
                    return count
                end)(),
                string.rep("-", 21)
            )
            
            local maxOres = math.min(10, #mapData.ores)
            for i = 1, maxOres do
                local o = mapData.ores[i]
                local oreName = o.name:match("(%w+)_ore") or "ore"
                local status = o.claimed and "C" or " "
                infoText = infoText .. string.format("[%s] %s\n  %d,%d,%d\n", 
                    status, oreName, o.x, o.y, o.z)
            end
            
            if #mapData.ores > 10 then
                infoText = infoText .. string.format("...+%d more", #mapData.ores - 10)
            end
            
            infoBox:setText(infoText)
            
            -- Status bar
            statusBar:setText(string.format(
                "ID:%d | Protocol:%s | Ores:%d | Press Q to quit",
                COMPUTER_ID, PROTOCOL, #mapData.ores
            ))
        end
        
        -- Initial update
        updateDisplay()
        addLog("SmartMiner started")
        addLog(string.format("Computer ID: %d", COMPUTER_ID))
        
        -- Schedule periodic updates
        main:addThread():start(function()
            while true do
                updateDisplay()
                sleep(1)
            end
        end)
        
        -- Schedule rednet listener
        main:addThread():start(function()
            while true do
                local senderId, message = rednet.receive(PROTOCOL, 0.5)
                if senderId then
                    addLog(string.format("< Turtle %d: %s", senderId, message.type or "?"))
                    handleRequest(senderId, message)
                    updateDisplay()
                end
            end
        end)
        
        -- Schedule auto-save
        main:addThread():start(function()
            while true do
                sleep(AUTO_SAVE_INTERVAL)
                saveMap()
                addLog(string.format("Map saved (%d ores)", #mapData.ores))
            end
        end)
        
        -- Quit handler
        main:onEvent(function(event, key)
            if event == "key" and key == keys.q then
                saveMap()
                basalt.stop()
            end
        end)
        
        print("Basalt GUI initialized. Press Q to quit.")
        
        -- Start Basalt (v2 API - NO .show() method)
        basalt.autoUpdate()
    end
end

----------------------------------
-- TEXT MODE FALLBACK
----------------------------------
if not BASALT then
    term.clear()
    term.setCursorPos(1, 1)
    print("═══════════════════════════════════")
    print("  SMARTMINER COMPUTER BRAIN")
    print("═══════════════════════════════════")
    print("Computer ID:", COMPUTER_ID)
    print("Protocol:", PROTOCOL)
    print("Scanner:", scanner and "OK" or "NOT FOUND")
    print("Modem:", modem and "OK" or "NOT FOUND")
    print("Disk Drive:", drive and "OK" or "NOT FOUND")
    print("")
    print("Current Ores:", #mapData.ores)
    print("")
    print("Listening for turtle requests...")
    print("Press Ctrl+T to stop")
    print("═══════════════════════════════════")
    print("")
    
    local lastSave = os.clock()
    local lastStatus = os.clock()
    
    while true do
        local senderId, message, protocol = rednet.receive(PROTOCOL, 1)
        if senderId then
            print(string.format("[%s] Turtle %d: %s", 
                os.date("%H:%M:%S"), senderId, message.type or "unknown"))
            handleRequest(senderId, message)
            
            -- Show ore count after handling request
            if message.type == "request_path" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "ore_mined" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "request_scan" then
                print(string.format("  -> Scanned blocks, total ores: %d", #mapData.ores))
            end
        end
        
        -- Auto-save
        if os.clock() - lastSave >= AUTO_SAVE_INTERVAL then
            saveMap()
            lastSave = os.clock()
            print(string.format("[%s] Map auto-saved (%d ores)", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
        
        -- Periodic status update
        if os.clock() - lastStatus >= 60 then
            lastStatus = os.clock()
            print(string.format("[%s] Status: %d ores tracked", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
    end
end
