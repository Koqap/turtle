-- SmartMiner Computer Brain (Advanced Computer + Geo Scanner + Basalt GUI)
-- Features: A* pathfinding, disk drive persistence, real-time GUI, request-response protocol

----------------------------------
-- CONFIGURATION
----------------------------------
local scannerSide = "right"          -- side where geo scanner is attached
local modemSide = "left"             -- side where wireless modem is attached
local BASALT = true                  -- set true if Basalt installed (v2 API)
local SCAN_RADIUS = 16               -- scanner radius (16 = 33x33x33 area)
local AUTO_SAVE_INTERVAL = 30        -- seconds
local PROTOCOL = "smartminer"        -- rednet protocol

-- IDs and networking
local COMPUTER_ID = os.getComputerID and os.getComputerID() or 1
local TURTLE_TIMEOUT = 5

----------------------------------
-- PERIPHERALS SETUP
----------------------------------
local scanner = peripheral.wrap("geo_scanner_1")  -- Use peripheral name
local modem = peripheral.wrap(modemSide)

-- Disk drive storage - DISABLED (causes disk full errors)
local drive = nil  -- Disabled to avoid disk space issues

if not scanner then
    print("WARNING: Geo scanner not found on geo_scanner_1")
end

-- Ensure rednet open
if modem and peripheral.getType(modemSide):find("modem") then
    rednet.open(modemSide)
else
    print("Warning: modem not found on " .. modemSide)
end

print("Note: Disk saving disabled - data stored in memory only")

----------------------------------
-- MAP DATA STRUCTURE
----------------------------------
local mapData = {
    visited = {},       -- ["x,y,z"] = true
    blocks = {},        -- ["x,y,z"] = blockName
    ores = {},          -- list of {x,y,z,name,claimed=false}
    home = {x=0,y=0,z=0},
}

----------------------------------
-- HELPERS
----------------------------------
local function keyFrom(x,y,z) 
    return x..","..y..","..z 
end

local function getDiskPath()
    if drive and drive.isDiskPresent() then 
        return drive.getMountPath() 
    end
    return nil
end

local function saveMap()
    local path = getDiskPath()
    if not path then 
        return  -- No disk, skip saving
    end
    
    -- Try to save, handle errors
    local ok, err = pcall(function()
        local f = fs.open(path.."/minerMap.txt", "w")
        if f then 
            f.write(textutils.serialize(mapData))
            f.close()
        end
    end)
    
    if not ok then
        print("Warning: Could not save to disk (disk full or error)")
        -- Continue anyway, don't crash
    end
end

local function loadMap()
    local path = getDiskPath()
    if not path then 
        print("No disk present for loading")
        return 
    end
    if fs.exists(path.."/minerMap.txt") then
        local f = fs.open(path.."/minerMap.txt", "r")
        if f then 
            local data = f.readAll()
            f.close()
            local ok, dat = pcall(function() return textutils.unserialize(data) end)
            if ok and type(dat) == "table" then 
                mapData = dat 
                print("Map loaded from disk")
            end
        end
    end
end

-- Load map on startup
loadMap()

----------------------------------
-- SCANNER WRAPPER
----------------------------------
local function doScan(radius)
    if not scanner or not scanner.scan then 
        print("No scanner available!")
        return {} 
    end
    local ok, res = pcall(function() return scanner.scan(radius) end)
    if not ok or not res then 
        print("Scan failed:", res)
        return {} 
    end
    return res
end

-- Ore definitions (supports both normal and deepslate)
local ORE_NAMES = {
    ["minecraft:iron_ore"] = true,
    ["minecraft:deepslate_iron_ore"] = true,
    ["minecraft:coal_ore"] = true,
    ["minecraft:deepslate_coal_ore"] = true,
    ["minecraft:gold_ore"] = true,
    ["minecraft:deepslate_gold_ore"] = true,
    ["minecraft:diamond_ore"] = true,
    ["minecraft:deepslate_diamond_ore"] = true,
    ["minecraft:emerald_ore"] = true,
    ["minecraft:deepslate_emerald_ore"] = true,
    ["minecraft:redstone_ore"] = true,
    ["minecraft:deepslate_redstone_ore"] = true,
    ["minecraft:lapis_ore"] = true,
    ["minecraft:deepslate_lapis_ore"] = true,
    ["minecraft:copper_ore"] = true,
    ["minecraft:deepslate_copper_ore"] = true,
}

local function addOresFromScan(scanList, scanX, scanY, scanZ)
    scanX = scanX or 0
    scanY = scanY or 0
    scanZ = scanZ or 0
    
    for _, b in ipairs(scanList) do
        -- Convert to absolute coordinates
        local absX, absY, absZ = scanX + b.x, scanY + b.y, scanZ + b.z
        
        -- Store block info
        mapData.blocks[keyFrom(absX, absY, absZ)] = b.name
        
        -- Add ores
        if ORE_NAMES[b.name] then
            local k = keyFrom(absX, absY, absZ)
            local exists = false
            for _, o in ipairs(mapData.ores) do 
                if o.x == absX and o.y == absY and o.z == absZ then 
                    exists = true
                    break 
                end 
            end
            if not exists then
                table.insert(mapData.ores, {
                    x = absX, 
                    y = absY, 
                    z = absZ, 
                    name = b.name, 
                    claimed = false
                })
            end
        end
    end
    saveMap()
end

----------------------------------
-- A* PATHFINDER (3D)
----------------------------------
local function neighbors(node)
    local x, y, z = node.x, node.y, node.z
    return {
        {x=x+1, y=y, z=z, dir="east"},
        {x=x-1, y=y, z=z, dir="west"},
        {x=x, y=y+1, z=z, dir="up"},
        {x=x, y=y-1, z=z, dir="down"},
        {x=x, y=y, z=z+1, dir="south"},
        {x=x, y=y, z=z-1, dir="north"},
    }
end

local function isBlocked(x, y, z)
    local name = mapData.blocks[keyFrom(x, y, z)]
    if not name then return false end
    -- treat known liquids/bedrock as blocked
    if name:find("lava") or name:find("water") or name == "minecraft:bedrock" then 
        return true 
    end
    return false
end

local function heuristic(a, b)
    return math.abs(a.x - b.x) + math.abs(a.y - b.y) + math.abs(a.z - b.z)
end

local function computePath(start, goal)
    local open = {}
    local openMap = {}
    local cameFrom = {}
    local gScore = {}
    local fScore = {}
    
    local function push(node)
        table.insert(open, node)
        openMap[keyFrom(node.x, node.y, node.z)] = true
    end
    
    local function popLowest()
        local bestIdx, bestF = 1, math.huge
        for i, node in ipairs(open) do
            local k = keyFrom(node.x, node.y, node.z)
            if fScore[k] and fScore[k] < bestF then 
                bestF = fScore[k]
                bestIdx = i 
            end
        end
        local node = table.remove(open, bestIdx)
        if node then 
            openMap[keyFrom(node.x, node.y, node.z)] = nil 
        end
        return node
    end
    
    local startKey = keyFrom(start.x, start.y, start.z)
    gScore[startKey] = 0
    fScore[startKey] = heuristic(start, goal)
    push({x=start.x, y=start.y, z=start.z})

    local iterations = 0
    local maxIterations = 10000
    
    while #open > 0 and iterations < maxIterations do
        iterations = iterations + 1
        local current = popLowest()
        
        if current.x == goal.x and current.y == goal.y and current.z == goal.z then
            -- reconstruct path
            local path = {}
            local curKey = keyFrom(current.x, current.y, current.z)
            while curKey do
                table.insert(path, 1, {x=current.x, y=current.y, z=current.z})
                local c = cameFrom[curKey]
                if not c then break end
                current = c
                curKey = keyFrom(current.x, current.y, current.z)
            end
            return path
        end
        
        for _, n in ipairs(neighbors(current)) do
            if not isBlocked(n.x, n.y, n.z) then
                local nk = keyFrom(n.x, n.y, n.z)
                local currentKey = keyFrom(current.x, current.y, current.z)
                local tentative = gScore[currentKey] + 1
                
                if not gScore[nk] or tentative < gScore[nk] then
                    cameFrom[nk] = current
                    gScore[nk] = tentative
                    fScore[nk] = tentative + heuristic(n, goal)
                    if not openMap[nk] then 
                        push({x=n.x, y=n.y, z=n.z}) 
                    end
                end
            end
        end
    end
    
    return nil -- no path found
end

----------------------------------
-- MESSAGE PROTOCOL HANDLERS
----------------------------------
local function handleRequest(id, msg)
    if type(msg) ~= "table" or not msg.type then 
        return 
    end

    if msg.type == "request_scan" then
        print(string.format("[%s] Scan request from turtle %d", os.time(), id))
        local scanX, scanY, scanZ = msg.x or 0, msg.y or 0, msg.z or 0
        local scan = doScan(SCAN_RADIUS)
        addOresFromScan(scan, scanX, scanY, scanZ)
        rednet.send(id, { 
            type = "scan_result", 
            ores = mapData.ores,
            scanned = #scan 
        }, PROTOCOL)
        print(string.format("  Sent %d ores to turtle", #mapData.ores))

    elseif msg.type == "request_path" then
        print(string.format("[%s] Path request from turtle %d", os.time(), id))
        local cx, cy, cz = msg.x, msg.y, msg.z
        print(string.format("  Turtle at: %d,%d,%d", cx, cy, cz))
        
        -- choose nearest unclaimed ore
        local bestIdx, bestDist = nil, math.huge
        for i, o in ipairs(mapData.ores) do
            if not o.claimed and not mapData.visited[keyFrom(o.x, o.y, o.z)] then
                local dx = o.x - cx
                local dy = o.y - cy
                local dz = o.z - cz
                local dist = math.abs(dx) + math.abs(dy) + math.abs(dz)
                if dist < bestDist then 
                    bestDist = dist
                    bestIdx = i 
                end
            end
        end
        
        if not bestIdx then
            print("  No available ores")
            rednet.send(id, { 
                type = "path", 
                steps = {} 
            }, PROTOCOL)
            return
        end
        
        -- mark claimed to avoid races
        mapData.ores[bestIdx].claimed = true
        saveMap()

        local target = mapData.ores[bestIdx]
        print(string.format("  Target ore: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        -- compute path with A*
        local path = nil
        local ok, res = pcall(function() 
            return computePath(
                {x=cx, y=cy, z=cz}, 
                {x=target.x, y=target.y, z=target.z}
            ) 
        end)
        
        if ok and res then
            path = res
            print(string.format("  Path found: %d steps", #path))
        else
            path = {}
            print("  Path computation failed:", res)
        end
        
        rednet.send(id, { 
            type = "path", 
            steps = path, 
            target = target 
        }, PROTOCOL)

    elseif msg.type == "ore_mined" then
        print(string.format("[%s] Ore mined report from turtle %d", os.time(), id))
        local ox, oy, oz = msg.x, msg.y, msg.z
        mapData.visited[keyFrom(ox, oy, oz)] = true
        
        -- remove ore from list
        for i, o in ipairs(mapData.ores) do
            if o.x == ox and o.y == oy and o.z == oz then 
                print(string.format("  Removed ore: %s at %d,%d,%d", o.name, ox, oy, oz))
                table.remove(mapData.ores, i)
                break 
            end
        end
        saveMap()
        
        -- Send acknowledgment
        rednet.send(id, {
            type = "ack",
            remaining = #mapData.ores
        }, PROTOCOL)
    end
end

----------------------------------
-- BASALT GUI v2 API
----------------------------------
if BASALT then
    print("Initializing Basalt GUI...")
    local ok, basalt = pcall(require, "basalt")
    
    if not ok then
        print("Basalt not available, using text mode")
        print("Error:", basalt)
        print("")
        print("To install Basalt, run:")
        print("  wget run https://basalt.madefor.cc/install.lua")
        print("")
        BASALT = false
    else
        -- Get main frame
        local main = basalt.getMainFrame()
        local w, h = term.getSize()
        
        -- Create title label
        local titleLabel = main:addLabel()
            :setText("SMARTMINER COMPUTER BRAIN")
            :setPosition(1, 1)
            :setSize(w, 1)
            :setBackground(colors.blue)
            :setForeground(colors.white)
        
        -- Create status label
        local statusLabel = main:addLabel()
            :setText("Initializing...")
            :setPosition(1, 2)
            :setSize(w, 1)
            :setBackground(colors.gray)
            :setForeground(colors.yellow)
        
        -- Create ore list label
        local oreListLabel = main:addLabel()
            :setText("Loading...")
            :setPosition(1, 4)
            :setSize(w, 20)
            :setBackground(colors.black)
            :setForeground(colors.white)
        
        -- Create scan button
        local scanButton = main:addButton()
            :setText("SCAN NOW")
            :setPosition(2, 3)
            :setSize(15, 1)
            :setBackground(colors.green)
            :setForeground(colors.white)
        
        -- Scan button click handler
        scanButton:onClick(function()
            addLog(">>> SCAN STARTED <<<")
            updateDisplay()
            
            local scan = doScan(SCAN_RADIUS)
            addLog(string.format("Scanned %d blocks", #scan))
            
            if #scan == 0 then
                addLog("ERROR: Geo scanner failed!")
                addLog("Check geo_scanner_1 connection")
            else
                local beforeOres = #mapData.ores
                addOresFromScan(scan, 0, 0, 0)
                local afterOres = #mapData.ores
                addLog(string.format("Found %d ores total", afterOres))
                
                if afterOres == beforeOres then
                    addLog("No NEW ores in scan area")
                else
                    addLog(string.format("Added %d new ores!", afterOres - beforeOres))
                end
            end
            updateDisplay()
        end)
        
        -- Create log label
        local logLabel = main:addLabel()
            :setText("Activity Log:")
            :setPosition(1, 25)
            :setSize(w, h - 24)
            :setBackground(colors.black)
            :setForeground(colors.lightGray)
        
        local logBuffer = {}
        local maxLogLines = 4
        
        local function addLog(text)
            table.insert(logBuffer, os.date("[%H:%M:%S] ") .. text)
            if #logBuffer > maxLogLines then
                table.remove(logBuffer, 1)
            end
            logLabel:setText("Activity Log:\n" .. table.concat(logBuffer, "\n"))
        end
        
        -- Update display function
        local function updateDisplay()
            -- Update status
            statusLabel:setText(string.format(
                " ID:%d | Protocol:%s | Ores:%d | Click SCAN button or Press Q=Quit",
                COMPUTER_ID, PROTOCOL, #mapData.ores
            ))
            
            -- Update ore list
            local oreText = {}
            table.insert(oreText, "Tracked Ores: " .. #mapData.ores)
            table.insert(oreText, string.rep("-", 40))
            
            if #mapData.ores == 0 then
                table.insert(oreText, "(No ores discovered yet)")
                table.insert(oreText, "")
                table.insert(oreText, "Waiting for turtle scan requests...")
            else
                local maxDisplay = 15
                for i = 1, math.min(maxDisplay, #mapData.ores) do
                    local o = mapData.ores[i]
                    local oreName = o.name:match("(%w+)_ore") or "ore"
                    local status = o.claimed and "[CLAIMED]" or "[  OPEN  ]"
                    table.insert(oreText, string.format("%s %s at %d,%d,%d", 
                        status, oreName, o.x, o.y, o.z))
                end
                
                if #mapData.ores > maxDisplay then
                    table.insert(oreText, "")
                    table.insert(oreText, string.format("...and %d more ores tracked", #mapData.ores - maxDisplay))
                end
            end
            
            oreListLabel:setText(table.concat(oreText, "\n"))
        end
        
        -- Initialize
        addLog("SmartMiner initialized")
        addLog(string.format("Computer ID: %d", COMPUTER_ID))
        
        -- Do initial scan on startup
        addLog("Performing initial scan...")
        updateDisplay()
        sleep(0.5)
        
        local initialScan = doScan(SCAN_RADIUS)
        addLog(string.format("Scanned %d blocks", #initialScan))
        
        if #initialScan == 0 then
            addLog("ERROR: Geo scanner not working!")
            addLog("Check RIGHT side connection")
        else
            local beforeOres = #mapData.ores
            addOresFromScan(initialScan, 0, 0, 0)
            local afterOres = #mapData.ores
            addLog(string.format("Found %d ores total", afterOres))
        end
        
        updateDisplay()
        
        -- Background thread: Update display
        basalt.schedule(function()
            while true do
                updateDisplay()
                sleep(2)
            end
        end)
        
        -- Background thread: Handle rednet requests
        basalt.schedule(function()
            while true do
                local senderId, message = rednet.receive(PROTOCOL, 1)
                if senderId and message then
                    addLog(string.format("Turtle %d: %s", senderId, message.type or "unknown"))
                    handleRequest(senderId, message)
                    updateDisplay()
                end
            end
        end)
        
        -- Background thread: Auto-save
        basalt.schedule(function()
            while true do
                sleep(AUTO_SAVE_INTERVAL)
                saveMap()
                addLog("Map auto-saved")
            end
        end)
        
        -- Keyboard handler thread
        basalt.schedule(function()
            while true do
                local event, key = os.pullEvent()
                if event == "key" then
                    if key == keys.q then
                        addLog("Shutting down...")
                        saveMap()
                        sleep(0.5)
                        basalt.stop()
                        break
                    elseif key == keys.s then
                        addLog(">>> SCAN STARTED <<<")
                        updateDisplay()
                        
                        local scan = doScan(SCAN_RADIUS)
                        addLog(string.format("Scanned %d blocks", #scan))
                        
                        if #scan == 0 then
                            addLog("ERROR: Geo scanner failed!")
                            addLog("Check scanner on RIGHT side")
                        else
                            local beforeOres = #mapData.ores
                            addOresFromScan(scan, 0, 0, 0)
                            local afterOres = #mapData.ores
                            addLog(string.format("Found %d new ores", afterOres - beforeOres))
                            
                            if afterOres == beforeOres then
                                addLog("No ores in 16 block radius")
                            end
                        end
                        updateDisplay()
                    end
                end
            end
        end)
        
        print("Basalt GUI initialized. Press Q to quit.")
        
        -- Start Basalt main loop
        basalt.run()
    end
end

----------------------------------
-- TEXT MODE FALLBACK
----------------------------------
if not BASALT then
    term.clear()
    term.setCursorPos(1, 1)
    print("═══════════════════════════════════")
    print("  SMARTMINER COMPUTER BRAIN")
    print("═══════════════════════════════════")
    print("Computer ID:", COMPUTER_ID)
    print("Protocol:", PROTOCOL)
    print("Scanner:", scanner and "OK" or "NOT FOUND")
    print("Modem:", modem and "OK" or "NOT FOUND")
    print("Disk Drive:", drive and "OK" or "NOT FOUND")
    print("")
    print("Current Ores:", #mapData.ores)
    print("")
    print("Listening for turtle requests...")
    print("Press Ctrl+T to stop")
    print("═══════════════════════════════════")
    print("")
    
    local lastSave = os.clock()
    local lastStatus = os.clock()
    
    while true do
        local senderId, message, protocol = rednet.receive(PROTOCOL, 1)
        if senderId then
            print(string.format("[%s] Turtle %d: %s", 
                os.date("%H:%M:%S"), senderId, message.type or "unknown"))
            handleRequest(senderId, message)
            
            -- Show ore count after handling request
            if message.type == "request_path" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "ore_mined" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "request_scan" then
                print(string.format("  -> Scanned blocks, total ores: %d", #mapData.ores))
            end
        end
        
        -- Auto-save
        if os.clock() - lastSave >= AUTO_SAVE_INTERVAL then
            saveMap()
            lastSave = os.clock()
            print(string.format("[%s] Map auto-saved (%d ores)", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
        
        -- Periodic status update
        if os.clock() - lastStatus >= 60 then
            lastStatus = os.clock()
            print(string.format("[%s] Status: %d ores tracked", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
    end
end
