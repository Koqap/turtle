-- SmartMiner Computer Brain (Advanced Computer + Geo Scanner + Basalt GUI)
-- Features: A* pathfinding, disk drive persistence, real-time GUI, request-response protocol

----------------------------------
-- CONFIGURATION
----------------------------------
local scannerSide = "right"          -- side where geo scanner is attached
local modemSide = "left"             -- side where wireless modem is attached
local monitorSide = nil              -- optional monitor (nil = auto-detect, "top"/"bottom"/etc)
local BASALT = true                  -- set true if Basalt installed (v2 API)
local SCAN_RADIUS = 16               -- scanner radius (16 = 33x33x33 area)
local AUTO_SAVE_INTERVAL = 30        -- seconds
local PROTOCOL = "smartminer"        -- rednet protocol
local MAX_MINING_RANGE = 60          -- max distance for ore mining (blocks)

-- IDs and networking
local COMPUTER_ID = os.getComputerID and os.getComputerID() or 1
local TURTLE_TIMEOUT = 5
local systemRunning = false  -- Manual start/stop control

----------------------------------
-- PERIPHERALS SETUP
----------------------------------
local scanner = peripheral.wrap("geo_scanner_1")  -- Use peripheral name
local modem = peripheral.wrap(modemSide)

-- Environment Detector (Advanced Peripherals) - Optional
local envDetector = peripheral.find("environmentDetector")

-- Disk drive storage - DISABLED (causes disk full errors)
local drive = nil  -- Disabled to avoid disk space issues

-- Optional monitor support
local monitor = nil
if monitorSide then
    monitor = peripheral.wrap(monitorSide)
else
    -- Auto-detect monitor
    monitor = peripheral.find("monitor")
end

-- Scanner status
if scanner then
    print("✓ Geo Scanner: Found (geo_scanner_1)")
else
    print("⚠ Geo Scanner: Not found (geo_scanner_1)")
end

-- Environment Detector status
if envDetector then
    print("✓ Environment Detector: Found (" .. peripheral.getName(envDetector) .. ")")
    local ok, maxRadius = pcall(function() return envDetector.getOperationRadius() end)
    if ok and maxRadius then
        print("  Max scan radius: " .. maxRadius)
    end
else
    print("⚠ Environment Detector: Not found (optional)")
end

-- Monitor status
if monitor then
    local mw, mh = monitor.getSize()
    print("✓ Monitor detected: " .. peripheral.getName(monitor))
    print("  Resolution: " .. mw .. "x" .. mh)
else
    print("⚠ No monitor detected (using computer screen)")
end

-- Ensure rednet open
if modem and peripheral.getType(modemSide):find("modem") then
    rednet.open(modemSide)
else
    print("Warning: modem not found on " .. modemSide)
end

print("Note: Disk saving disabled - data stored in memory only")

----------------------------------
-- MAP DATA STRUCTURE
----------------------------------
local mapData = {
    visited = {},       -- ["x,y,z"] = true
    blocks = {},        -- ["x,y,z"] = blockName
    ores = {},          -- list of {x,y,z,name,claimed=false}
    home = {x=0,y=0,z=0},
}

----------------------------------
-- HELPERS
----------------------------------
local function keyFrom(x,y,z) 
    return x..","..y..","..z 
end

local function getDiskPath()
    if drive and drive.isDiskPresent() then 
        return drive.getMountPath() 
    end
    return nil
end

local function saveMap()
    local path = getDiskPath()
    if not path then 
        return  -- No disk, skip saving
    end
    
    -- Try to save, handle errors
    local ok, err = pcall(function()
        local f = fs.open(path.."/minerMap.txt", "w")
        if f then 
            f.write(textutils.serialize(mapData))
            f.close()
        end
    end)
    
    if not ok then
        print("Warning: Could not save to disk (disk full or error)")
        -- Continue anyway, don't crash
    end
end

local function loadMap()
    local path = getDiskPath()
    if not path then 
        print("No disk present for loading")
        return 
    end
    if fs.exists(path.."/minerMap.txt") then
        local f = fs.open(path.."/minerMap.txt", "r")
        if f then 
            local data = f.readAll()
            f.close()
            local ok, dat = pcall(function() return textutils.unserialize(data) end)
            if ok and type(dat) == "table" then 
                mapData = dat 
                print("Map loaded from disk")
            end
        end
    end
end

-- Load map on startup
loadMap()

----------------------------------
-- SCANNER WRAPPER
----------------------------------
local function doScan(radius)
    if not scanner or not scanner.scan then 
        print("No scanner available!")
        return {} 
    end
    local ok, res = pcall(function() return scanner.scan(radius) end)
    if not ok or not res then 
        print("Scan failed:", res)
        return {} 
    end
    return res
end

-- Environment Detector scanning (Alternative/Complementary)
local function doScanWithEnvDetector(radius)
    if not envDetector then 
        print("No Environment Detector available!")
        return {} 
    end
    
    print(string.format("Scanning with Environment Detector (radius: %d)...", radius))
    local ok, blocks = pcall(function() return envDetector.scan(radius) end)
    
    if not ok or not blocks then 
        print("Environment Detector scan failed:", blocks)
        return {} 
    end
    
    print(string.format("  Environment Detector scanned %d blocks", #blocks))
    
    -- Convert Environment Detector format to geo scanner format
    -- EnvDetector returns: {x, y, z, name, tags}
    -- GeoScanner expects: {x, y, z, name, state}
    local converted = {}
    for _, block in ipairs(blocks) do
        if block.name then
            table.insert(converted, {
                x = block.x or 0,
                y = block.y or 0,
                z = block.z or 0,
                name = block.name,
                state = block.state or {},
                tags = block.tags or {}
            })
        end
    end
    
    return converted
end

-- Hybrid scan: Use both scanners if available
local function doHybridScan(radius)
    local results = {}
    local geoResults = {}
    local envResults = {}
    
    -- Try geo scanner first
    if scanner then
        geoResults = doScan(radius)
        print(string.format("  Geo scanner: %d blocks", #geoResults))
    end
    
    -- Try environment detector
    if envDetector then
        envResults = doScanWithEnvDetector(radius)
        print(string.format("  Env detector: %d blocks", #envResults))
    end
    
    -- Use whichever got more results (or combine them)
    if #geoResults > 0 then
        results = geoResults
    elseif #envResults > 0 then
        results = envResults
    end
    
    return results
end

-- Ore definitions (supports both normal and deepslate)
local ORE_NAMES = {
    ["minecraft:iron_ore"] = true,
    ["minecraft:deepslate_iron_ore"] = true,
    ["minecraft:coal_ore"] = true,
    ["minecraft:deepslate_coal_ore"] = true,
    ["minecraft:gold_ore"] = true,
    ["minecraft:deepslate_gold_ore"] = true,
    ["minecraft:diamond_ore"] = true,
    ["minecraft:deepslate_diamond_ore"] = true,
    ["minecraft:emerald_ore"] = true,
    ["minecraft:deepslate_emerald_ore"] = true,
    ["minecraft:redstone_ore"] = true,
    ["minecraft:deepslate_redstone_ore"] = true,
    ["minecraft:lapis_ore"] = true,
    ["minecraft:deepslate_lapis_ore"] = true,
    ["minecraft:copper_ore"] = true,
    ["minecraft:deepslate_copper_ore"] = true,
}

local function addOresFromScan(scanList, scanX, scanY, scanZ)
    scanX = scanX or 0
    scanY = scanY or 0
    scanZ = scanZ or 0
    
    for _, b in ipairs(scanList) do
        -- Convert to absolute coordinates
        local absX, absY, absZ = scanX + b.x, scanY + b.y, scanZ + b.z
        
        -- Store block info
        mapData.blocks[keyFrom(absX, absY, absZ)] = b.name
        
        -- Add ores
        if ORE_NAMES[b.name] then
            local k = keyFrom(absX, absY, absZ)
            local exists = false
            for _, o in ipairs(mapData.ores) do 
                if o.x == absX and o.y == absY and o.z == absZ then 
                    exists = true
                    break 
                end 
            end
            if not exists then
                table.insert(mapData.ores, {
                    x = absX, 
                    y = absY, 
                    z = absZ, 
                    name = b.name, 
                    claimed = false
                })
            end
        end
    end
    saveMap()
end

----------------------------------
-- A* PATHFINDER (3D)
----------------------------------
local function neighbors(node)
    local x, y, z = node.x, node.y, node.z
    return {
        {x=x+1, y=y, z=z, dir="east"},
        {x=x-1, y=y, z=z, dir="west"},
        {x=x, y=y+1, z=z, dir="up"},
        {x=x, y=y-1, z=z, dir="down"},
        {x=x, y=y, z=z+1, dir="south"},
        {x=x, y=y, z=z-1, dir="north"},
    }
end

local function isBlocked(x, y, z)
    local name = mapData.blocks[keyFrom(x, y, z)]
    if not name then return false end
    -- treat known liquids/bedrock as blocked
    if name:find("lava") or name:find("water") or name == "minecraft:bedrock" then 
        return true 
    end
    return false
end

local function heuristic(a, b)
    return math.abs(a.x - b.x) + math.abs(a.y - b.y) + math.abs(a.z - b.z)
end

local function computePath(start, goal)
    local open = {}
    local openMap = {}
    local cameFrom = {}
    local gScore = {}
    local fScore = {}
    
    local function push(node)
        table.insert(open, node)
        openMap[keyFrom(node.x, node.y, node.z)] = true
    end
    
    local function popLowest()
        local bestIdx, bestF = 1, math.huge
        for i, node in ipairs(open) do
            local k = keyFrom(node.x, node.y, node.z)
            if fScore[k] and fScore[k] < bestF then 
                bestF = fScore[k]
                bestIdx = i 
            end
        end
        local node = table.remove(open, bestIdx)
        if node then 
            openMap[keyFrom(node.x, node.y, node.z)] = nil 
        end
        return node
    end
    
    local startKey = keyFrom(start.x, start.y, start.z)
    gScore[startKey] = 0
    fScore[startKey] = heuristic(start, goal)
    push({x=start.x, y=start.y, z=start.z})

    local iterations = 0
    local maxIterations = 10000
    
    while #open > 0 and iterations < maxIterations do
        iterations = iterations + 1
        local current = popLowest()
        
        if current.x == goal.x and current.y == goal.y and current.z == goal.z then
            -- reconstruct path
            local path = {}
            local curKey = keyFrom(current.x, current.y, current.z)
            while curKey do
                table.insert(path, 1, {x=current.x, y=current.y, z=current.z})
                local c = cameFrom[curKey]
                if not c then break end
                current = c
                curKey = keyFrom(current.x, current.y, current.z)
            end
            return path
        end
        
        for _, n in ipairs(neighbors(current)) do
            if not isBlocked(n.x, n.y, n.z) then
                local nk = keyFrom(n.x, n.y, n.z)
                local currentKey = keyFrom(current.x, current.y, current.z)
                local tentative = gScore[currentKey] + 1
                
                if not gScore[nk] or tentative < gScore[nk] then
                    cameFrom[nk] = current
                    gScore[nk] = tentative
                    fScore[nk] = tentative + heuristic(n, goal)
                    if not openMap[nk] then 
                        push({x=n.x, y=n.y, z=n.z}) 
                    end
                end
            end
        end
    end
    
    return nil -- no path found
end

----------------------------------
-- ORE FILTER STATE (used by GUI and handler)
----------------------------------
local oreFilterEnabled = {
    iron = true,
    coal = true,
    gold = true,
    diamond = true,
    copper = false,
    redstone = false,
    lapis = false,
    emerald = false,
}

----------------------------------
-- TURTLE TRACKING
----------------------------------
local turtles = {}  -- Track connected turtles

local function updateTurtle(id, data)
    if not turtles[id] then
        turtles[id] = {
            id = id,
            lastSeen = os.epoch("utc"),
            position = {x=0, y=0, z=0},
            status = "connected",
            oresMined = 0,
            currentTarget = nil,
        }
    end
    
    for k, v in pairs(data) do
        turtles[id][k] = v
    end
    turtles[id].lastSeen = os.epoch("utc")
end

----------------------------------
-- MESSAGE PROTOCOL HANDLERS
----------------------------------
local function handleRequest(id, msg)
    if type(msg) ~= "table" or not msg.type then 
        return 
    end

    if msg.type == "ping" then
        -- Simple ping response for connection testing (always respond to pings)
        print(string.format("[PING] Turtle %d connected", id))
        updateTurtle(id, {status = "connected"})
        rednet.send(id, {type = "pong"}, PROTOCOL)
        
    elseif not systemRunning then
        -- System stopped - ignore all requests except ping
        print(string.format("[%s] Ignored request from turtle %d (system stopped)", os.time(), id))
        return
        
    elseif msg.type == "request_scan" then
        print(string.format("[%s] Scan request from turtle %d", os.time(), id))
        local scanX, scanY, scanZ = msg.x or 0, msg.y or 0, msg.z or 0
        
        -- Use hybrid scan if Environment Detector available, otherwise use geo scanner
        local scan
        if envDetector then
            scan = doHybridScan(SCAN_RADIUS)
        else
            scan = doScan(SCAN_RADIUS)
        end
        
        addOresFromScan(scan, scanX, scanY, scanZ)
        rednet.send(id, { 
            type = "scan_result", 
            ores = mapData.ores,
            scanned = #scan,
            has_envdetector = envDetector ~= nil  -- Tell turtle if we have environment detector
        }, PROTOCOL)
        print(string.format("  Sent %d ores to turtle", #mapData.ores))
        if envDetector then
            print("  Environment Detector: Available for smart navigation")
        end

    elseif msg.type == "request_path" then
        print(string.format("[%s] Path request from turtle %d", os.time(), id))
        local cx, cy, cz = msg.x, msg.y, msg.z
        local oreFilter = msg.oreFilter  -- Get ore filter from turtle
        print(string.format("  Turtle at: %d,%d,%d", cx, cy, cz))
        
        -- Update turtle tracking
        updateTurtle(id, {
            position = {x=cx, y=cy, z=cz},
            status = "requesting path"
        })
        
        -- Helper function to check if ore matches filter
        local function matchesFilter(oreName)
            -- First check GUI filter (if available and in GUI mode)
            if BASALT and oreFilterEnabled then
                for oreType, enabled in pairs(oreFilterEnabled) do
                    if oreName:find(oreType) and enabled then
                        return true
                    end
                end
                return false
            end
            
            -- Fallback to turtle's filter
            if not oreFilter then return true end  -- No filter = mine all
            for _, filterType in ipairs(oreFilter) do
                if oreName:find(filterType) then
                    return true
                end
            end
            return false
        end
        
        -- Find all nearby ores within range and sort by distance
        local nearbyOres = {}
        local totalOres = 0
        local filteredOres = 0
        local outOfRange = 0
        
        for i, o in ipairs(mapData.ores) do
            if not o.claimed and not mapData.visited[keyFrom(o.x, o.y, o.z)] then
                totalOres = totalOres + 1
                
                -- Check if ore matches filter
                if matchesFilter(o.name) then
                    filteredOres = filteredOres + 1
                    
                    -- Calculate distance (Manhattan distance)
                    local dx = o.x - cx
                    local dy = o.y - cy
                    local dz = o.z - cz
                    local dist = math.abs(dx) + math.abs(dy) + math.abs(dz)
                    
                    -- Only consider ores within MAX_MINING_RANGE
                    if dist <= MAX_MINING_RANGE then
                        table.insert(nearbyOres, {
                            index = i,
                            ore = o,
                            distance = dist
                        })
                    else
                        outOfRange = outOfRange + 1
                    end
                end
            end
        end
        
        -- Sort nearby ores by distance (nearest first)
        table.sort(nearbyOres, function(a, b) return a.distance < b.distance end)
        
        print(string.format("  Ore stats: %d total, %d filtered, %d in range, %d too far", 
            totalOres, filteredOres, #nearbyOres, outOfRange))
        
        -- Choose the nearest ore
        if #nearbyOres == 0 then
            if outOfRange > 0 then
                print(string.format("  No ores within %d blocks (all ores too far)", MAX_MINING_RANGE))
                print("  Turtle should return to base or scan new area")
            else
                print("  No available ores matching filter")
            end
            rednet.send(id, { 
                type = "path", 
                steps = {} 
            }, PROTOCOL)
            return
        end

        local nearest = nearbyOres[1]
        local target = nearest.ore
        local bestIdx = nearest.index
        local bestDist = nearest.distance
        
        print(string.format("  Target: %s at %d,%d,%d (distance: %d blocks)", 
            target.name, target.x, target.y, target.z, math.floor(bestDist)))
        
        -- Show next 2 nearest ores for planning
        if #nearbyOres > 1 then
            print(string.format("  Next: %s at distance %d", 
                nearbyOres[2].ore.name, math.floor(nearbyOres[2].distance)))
        end
        if #nearbyOres > 2 then
            print(string.format("  After: %s at distance %d", 
                nearbyOres[3].ore.name, math.floor(nearbyOres[3].distance)))
        end
        
        -- SIMPLIFIED PATH: Just send the target coordinates
        -- The turtle will navigate there directly without complex A*
        local simplePath = {{x=target.x, y=target.y, z=target.z}}
        
        -- Mark as claimed ONLY after sending
        mapData.ores[bestIdx].claimed = true
        saveMap()
        
        -- Update turtle tracking
        updateTurtle(id, {
            status = "mining",
            currentTarget = target
        })
        
        print(string.format("  Sent target to turtle %d", id))
        
        rednet.send(id, { 
            type = "path", 
            steps = simplePath, 
            target = target,
            has_envdetector = envDetector ~= nil  -- Tell turtle if scanner has environment detector
        }, PROTOCOL)

    elseif msg.type == "ore_mined" then
        print(string.format("[%s] Ore mined report from turtle %d", os.time(), id))
        local ox, oy, oz = msg.x, msg.y, msg.z
        mapData.visited[keyFrom(ox, oy, oz)] = true
        
        -- Update turtle tracking
        if turtles[id] then
            turtles[id].oresMined = (turtles[id].oresMined or 0) + 1
            turtles[id].status = "ore mined"
            turtles[id].currentTarget = nil
        end
        
        -- remove ore from list
        for i, o in ipairs(mapData.ores) do
            if o.x == ox and o.y == oy and o.z == oz then 
                print(string.format("  Removed ore: %s at %d,%d,%d", o.name, ox, oy, oz))
                table.remove(mapData.ores, i)
                break 
            end
        end
        saveMap()
        
        -- Send acknowledgment
        rednet.send(id, {
            type = "ack",
            remaining = #mapData.ores
        }, PROTOCOL)
        
    elseif msg.type == "ore_failed" then
        print(string.format("[%s] Ore unreachable from turtle %d", os.time(), id))
        local ox, oy, oz = msg.x, msg.y, msg.z
        
        -- Unclaim the ore so another turtle can try, or mark as visited
        for i, o in ipairs(mapData.ores) do
            if o.x == ox and o.y == oy and o.z == oz then 
                print(string.format("  Marking unreachable: %s at %d,%d,%d", o.name, ox, oy, oz))
                -- Mark as visited so we don't keep trying
                mapData.visited[keyFrom(ox, oy, oz)] = true
                table.remove(mapData.ores, i)
                break 
            end
        end
        saveMap()
        
    elseif msg.type == "request_environment" then
        print(string.format("[%s] Environment scan request from turtle %d", os.time(), id))
        
        if not envDetector then
            print("  No Environment Detector available")
            rednet.send(id, {
                type = "environment_result",
                available = false
            }, PROTOCOL)
            return
        end
        
        local tx, ty, tz = msg.x or 0, msg.y or 0, msg.z or 0
        local radius = msg.radius or 8  -- Default 8 block scan
        
        print(string.format("  Scanning %d blocks around turtle position...", radius))
        local blocks = doScanWithEnvDetector(radius)
        
        -- Filter for obstacles (solid blocks turtle can't move through)
        local obstacles = {}
        for _, block in ipairs(blocks) do
            -- Add blocks that might be obstacles
            if block.name and not block.name:find("air") then
                table.insert(obstacles, {
                    x = block.x,
                    y = block.y,
                    z = block.z,
                    name = block.name
                })
            end
        end
        
        print(string.format("  Found %d obstacles", #obstacles))
        rednet.send(id, {
            type = "environment_result",
            available = true,
            obstacles = obstacles,
            scanned = #blocks
        }, PROTOCOL)
        
    elseif msg.type == "status_update" then
        print(string.format("[%s] Turtle %d: %s", os.time(), id, msg.status))
        
        -- Update turtle tracking
        updateTurtle(id, {
            status = msg.status,
            position = msg.position or {x=0, y=0, z=0}
        })
    end
end

----------------------------------
-- BASALT GUI v2 API
----------------------------------
if BASALT then
    print("Initializing Basalt GUI...")
    local ok, basalt = pcall(require, "basalt")
    
    if not ok then
        print("Basalt not available, using text mode")
        print("Error:", basalt)
        print("")
        print("To install Basalt, run:")
        print("  wget run https://basalt.madefor.cc/install.lua")
        print("")
        BASALT = false
    else
        -- Get main frame
        local main = basalt.getMainFrame()
        local w, h = term.getSize()
        
        -- Create title label
        local titleLabel = main:addLabel()
            :setText("SMARTMINER COMPUTER BRAIN")
            :setPosition(1, 1)
            :setSize(w, 1)
            :setBackground(colors.blue)
            :setForeground(colors.white)
        
        -- Create status label
        local statusLabel = main:addLabel()
            :setText("Initializing...")
            :setPosition(1, 2)
            :setSize(w, 1)
            :setBackground(colors.gray)
            :setForeground(colors.yellow)
        
        -- Create ore list label
        local oreListLabel = main:addLabel()
            :setText("Loading...")
            :setPosition(1, 8)
            :setSize(w, 6)
            :setBackground(colors.black)
            :setForeground(colors.white)
        
        -- Create turtle status label
        local turtleStatusLabel = main:addLabel()
            :setText("No turtles connected")
            :setPosition(1, 15)
            :setSize(w, 6)
            :setBackground(colors.gray)
            :setForeground(colors.white)
        
        -- Create log label
        local logLabel = main:addLabel()
            :setText("Activity Log:")
            :setPosition(1, 22)
            :setSize(w, h - 21)
            :setBackground(colors.black)
            :setForeground(colors.lightGray)
        
        -- Define log buffer and addLog function FIRST
        local logBuffer = {}
        local maxLogLines = 4
        
        local function addLog(text)
            table.insert(logBuffer, os.date("[%H:%M:%S] ") .. text)
            if #logBuffer > maxLogLines then
                table.remove(logBuffer, 1)
            end
            logLabel:setText("Activity Log:\n" .. table.concat(logBuffer, "\n"))
        end
        
        -- Monitor display function (DEFINE BEFORE updateDisplay)
        local function updateMonitor()
            if not monitor then return end
            
            local oldTerm = term.redirect(monitor)
            term.clear()
            term.setCursorPos(1, 1)
            
            -- Header
            term.setTextColor(colors.yellow)
            term.setBackgroundColor(colors.blue)
            local mw, mh = monitor.getSize()
            term.write(string.rep(" ", mw))
            term.setCursorPos(1, 1)
            term.write("SMARTMINER STATUS MONITOR")
            
            -- Stats
            term.setBackgroundColor(colors.black)
            term.setTextColor(colors.white)
            term.setCursorPos(1, 3)
            term.write(string.format("Ores Tracked: %d", #mapData.ores))
            
            -- Turtle list
            term.setCursorPos(1, 5)
            term.setTextColor(colors.lime)
            term.write("ACTIVE TURTLES:")
            
            local turtleCount = 0
            for _ in pairs(turtles) do turtleCount = turtleCount + 1 end
            
            if turtleCount == 0 then
                term.setCursorPos(1, 6)
                term.setTextColor(colors.gray)
                term.write("No turtles connected")
            else
                local line = 6
                for id, t in pairs(turtles) do
                    term.setCursorPos(1, line)
                    term.setTextColor(colors.white)
                    term.write(string.format("Turtle #%d", id))
                    
                    line = line + 1
                    term.setCursorPos(3, line)
                    term.setTextColor(colors.lightGray)
                    term.write(string.format("Status: %s", t.status))
                    
                    line = line + 1
                    term.setCursorPos(3, line)
                    term.write(string.format("Pos: %d, %d, %d", t.position.x, t.position.y, t.position.z))
                    
                    line = line + 1
                    term.setCursorPos(3, line)
                    term.setTextColor(colors.yellow)
                    term.write(string.format("Ores Mined: %d", t.oresMined))
                    
                    if t.currentTarget then
                        line = line + 1
                        term.setCursorPos(3, line)
                        term.setTextColor(colors.orange)
                        local oreName = t.currentTarget.name:match("(%w+)_ore") or "ore"
                        term.write(string.format("Target: %s at %d,%d,%d", 
                            oreName, t.currentTarget.x, t.currentTarget.y, t.currentTarget.z))
                    end
                    
                    line = line + 2
                    if line >= mh - 1 then break end
                end
            end
            
            -- Footer
            term.setCursorPos(1, mh)
            term.setBackgroundColor(colors.gray)
            term.setTextColor(colors.white)
            term.write(string.rep(" ", mw))
            term.setCursorPos(1, mh)
            term.write(string.format("Last Update: %s", os.date("%H:%M:%S")))
            
            term.redirect(oldTerm)
        end
        
        -- Define updateDisplay function BEFORE button
        local function updateDisplay()
            -- Update status with environment detector info
            local envStatus = envDetector and "EnvDet:OK" or "EnvDet:NO"
            local scannerStatus = scanner and "Geo:OK" or "Geo:NO"
            statusLabel:setText(string.format(
                " ID:%d | %s | %s | Ores:%d | Range:%d | Q=Quit",
                COMPUTER_ID, scannerStatus, envStatus, #mapData.ores, MAX_MINING_RANGE
            ))
            
            -- Update ore list
            local oreText = {}
            table.insert(oreText, "Tracked Ores: " .. #mapData.ores)
            table.insert(oreText, string.rep("-", 40))
            
            if #mapData.ores == 0 then
                table.insert(oreText, "(No ores - click SCAN)")
            else
                local maxDisplay = 5
                for i = 1, math.min(maxDisplay, #mapData.ores) do
                    local o = mapData.ores[i]
                    local oreName = o.name:match("(%w+)_ore") or "ore"
                    local status = o.claimed and "[BUSY]" or "[OPEN]"
                    table.insert(oreText, string.format("%s %s %d,%d,%d", 
                        status, oreName, o.x, o.y, o.z))
                end
                
                if #mapData.ores > maxDisplay then
                    table.insert(oreText, string.format("+%d more", #mapData.ores - maxDisplay))
                end
            end
            
            oreListLabel:setText(table.concat(oreText, "\n"))
            
            -- Update turtle status
            local turtleText = {}
            local turtleCount = 0
            for _, t in pairs(turtles) do
                turtleCount = turtleCount + 1
            end
            
            if turtleCount == 0 then
                table.insert(turtleText, "━━━ TURTLE STATUS ━━━")
                table.insert(turtleText, "No turtles connected")
                table.insert(turtleText, "")
                table.insert(turtleText, "Waiting for miner_v2...")
            else
                table.insert(turtleText, string.format("━━━ ACTIVE TURTLES: %d ━━━", turtleCount))
                
                for id, t in pairs(turtles) do
                    local pos = string.format("%d,%d,%d", t.position.x, t.position.y, t.position.z)
                    local target = "Idle"
                    if t.currentTarget then
                        local oreName = t.currentTarget.name:match("(%w+)_ore") or "ore"
                        target = string.format("%s@%d,%d,%d", oreName, 
                            t.currentTarget.x, t.currentTarget.y, t.currentTarget.z)
                    end
                    
                    table.insert(turtleText, string.format(
                        "#%d [%s] Pos:%s Mined:%d", 
                        id, t.status, pos, t.oresMined
                    ))
                    table.insert(turtleText, string.format("  -> %s", target))
                end
            end
            
            turtleStatusLabel:setText(table.concat(turtleText, "\n"))
            
            -- Update external monitor if available
            if monitor then
                updateMonitor()
            end
        end
        
        -- Create start/stop button
        local startStopButton = main:addButton()
            :setText("START")
            :setPosition(2, 2)
            :setSize(9, 1)
            :setBackground(colors.green)
            :setForeground(colors.white)
        
        -- Create scan button
        local scanButton = main:addButton()
            :setText("SCAN")
            :setPosition(12, 2)
            :setSize(8, 1)
            :setBackground(colors.blue)
            :setForeground(colors.white)
        
        -- Create return home button
        local returnButton = main:addButton()
            :setText("RETURN")
            :setPosition(21, 2)
            :setSize(9, 1)
            :setBackground(colors.orange)
            :setForeground(colors.white)
        
        -- Create ore filter label
        local filterLabel = main:addLabel()
            :setText("ORE FILTERS:")
            :setPosition(2, 4)
            :setSize(28, 1)
            :setBackground(colors.black)
            :setForeground(colors.orange)
        
        -- Create ore filter buttons (2 rows of 4)
        local btnY = 5
        local btnX = 2
        local oreButtons = {}
        
        local oreTypes = {"iron", "coal", "gold", "diamond", "copper", "redstone", "lapis", "emerald"}
        
        for i, oreType in ipairs(oreTypes) do
            local btn = main:addButton()
                :setText(string.upper(oreType:sub(1,4)))
                :setPosition(btnX + ((i-1) % 4) * 7, btnY + math.floor((i-1) / 4))
                :setSize(6, 1)
            
            -- Set initial color
            if oreFilterEnabled[oreType] then
                btn:setBackground(colors.lime)
            else
                btn:setBackground(colors.red)
            end
            btn:setForeground(colors.white)
            
            -- Click handler
            btn:onClick(function()
                oreFilterEnabled[oreType] = not oreFilterEnabled[oreType]
                if oreFilterEnabled[oreType] then
                    btn:setBackground(colors.lime)
                    addLog("Enabled: " .. oreType)
                else
                    btn:setBackground(colors.red)
                    addLog("Disabled: " .. oreType)
                end
            end)
            
            oreButtons[oreType] = btn
        end
        
        -- Start/Stop button handler
        startStopButton:onClick(function()
            systemRunning = not systemRunning
            
            if systemRunning then
                startStopButton:setText("STOP")
                startStopButton:setBackground(colors.red)
                addLog(">>> SYSTEM STARTED <<<")
                addLog("Turtles can now request scans and paths")
            else
                startStopButton:setText("START")
                startStopButton:setBackground(colors.green)
                addLog(">>> SYSTEM STOPPED <<<")
                addLog("Turtles will not receive responses")
            end
            updateDisplay()
        end)
        
        -- Scan button click handler (NOW addLog is defined)
        scanButton:onClick(function()
            addLog(">>> MANUAL SCAN <<<")
            updateDisplay()
            
            -- Use hybrid scan if available
            local scan
            if envDetector then
                addLog("Using hybrid scan (Geo + Environment Detector)")
                scan = doHybridScan(SCAN_RADIUS)
            else
                addLog("Using geo scanner only")
                scan = doScan(SCAN_RADIUS)
            end
            
            addLog(string.format("Scanned %d blocks", #scan))
            
            if #scan == 0 then
                addLog("ERROR: Scanner failed!")
                if not scanner and not envDetector then
                    addLog("No scanners available!")
                elseif scanner and not envDetector then
                    addLog("Check geo_scanner_1 connection")
                elseif envDetector and not scanner then
                    addLog("Check Environment Detector")
                end
            else
                local beforeOres = #mapData.ores
                addOresFromScan(scan, 0, 0, 0)
                local afterOres = #mapData.ores
                addLog(string.format("Found %d ores total", afterOres))
                
                if afterOres == beforeOres then
                    addLog("No NEW ores in scan area")
                else
                    addLog(string.format("Added %d new ores!", afterOres - beforeOres))
                end
            end
            updateDisplay()
        end)
        
        returnButton:onClick(function()
            addLog("RETURN button clicked")
            
            local turtleCount = 0
            local sentTo = {}
            
            for id, data in pairs(turtles) do
                turtleCount = turtleCount + 1
                table.insert(sentTo, id)
                
                -- Send return home command
                local success = rednet.send(id, {
                    type = "return_home"
                }, PROTOCOL)
                
                if success then
                    addLog(string.format("→ Sent RETURN to Turtle #%d", id))
                    print(string.format("Sent return_home to turtle %d", id))
                else
                    addLog(string.format("✗ Failed to send to Turtle #%d", id))
                end
            end
            
            if turtleCount == 0 then
                addLog("✗ No turtles connected!")
                print("WARNING: No turtles in tracking list")
                print("Turtles table is empty")
            else
                addLog(string.format(">>> Sent RETURN to %d turtle(s) <<<", turtleCount))
                print(string.format("Return command sent to turtles: %s", table.concat(sentTo, ", ")))
            end
            
            updateDisplay()
        end)
        
        -- Initialize
        addLog("SmartMiner initialized")
        addLog(string.format("Computer ID: %d", COMPUTER_ID))
        addLog(string.format("Mining range: %d blocks", MAX_MINING_RANGE))
        addLog("")
        addLog("Click START to begin operations")
        addLog("Click SCAN for manual scan")
        addLog("Click RETURN to recall turtles")
        
        updateDisplay()
        
        -- Background thread: Update display
        basalt.schedule(function()
            while true do
                updateDisplay()
                sleep(2)
            end
        end)
        
        -- Background thread: Handle rednet requests
        basalt.schedule(function()
            while true do
                local senderId, message = rednet.receive(PROTOCOL, 1)
                if senderId and message then
                    addLog(string.format("Turtle %d: %s", senderId, message.type or "unknown"))
                    handleRequest(senderId, message)
                    updateDisplay()
                end
            end
        end)
        
        -- Background thread: Auto-save
        basalt.schedule(function()
            while true do
                sleep(AUTO_SAVE_INTERVAL)
                saveMap()
                addLog("Map auto-saved")
            end
        end)
        
        -- Keyboard handler thread
        basalt.schedule(function()
            while true do
                local event, key = os.pullEvent()
                if event == "key" then
                    if key == keys.q then
                        addLog("Shutting down...")
                        saveMap()
                        sleep(0.5)
                        basalt.stop()
                        break
                    elseif key == keys.s then
                        addLog(">>> SCAN STARTED <<<")
                        updateDisplay()
                        
                        local scan = doScan(SCAN_RADIUS)
                        addLog(string.format("Scanned %d blocks", #scan))
                        
                        if #scan == 0 then
                            addLog("ERROR: Geo scanner failed!")
                            addLog("Check scanner on RIGHT side")
                        else
                            local beforeOres = #mapData.ores
                            addOresFromScan(scan, 0, 0, 0)
                            local afterOres = #mapData.ores
                            addLog(string.format("Found %d new ores", afterOres - beforeOres))
                            
                            if afterOres == beforeOres then
                                addLog("No ores in 16 block radius")
                            end
                        end
                        updateDisplay()
                    end
                end
            end
        end)
        
        print("Basalt GUI initialized. Press Q to quit.")
        
        -- Start Basalt main loop
        basalt.run()
    end
end

----------------------------------
-- TEXT MODE FALLBACK
----------------------------------
if not BASALT then
    term.clear()
    term.setCursorPos(1, 1)
    print("═══════════════════════════════════")
    print("  SMARTMINER COMPUTER BRAIN")
    print("═══════════════════════════════════")
    print("Computer ID:", COMPUTER_ID)
    print("Protocol:", PROTOCOL)
    print("Scanner:", scanner and "OK" or "NOT FOUND")
    print("Modem:", modem and "OK" or "NOT FOUND")
    print("Disk Drive:", drive and "OK" or "NOT FOUND")
    print("")
    print("Current Ores:", #mapData.ores)
    print("")
    print("Listening for turtle requests...")
    print("Press Ctrl+T to stop")
    print("═══════════════════════════════════")
    print("")
    
    local lastSave = os.clock()
    local lastStatus = os.clock()
    
    while true do
        local senderId, message, protocol = rednet.receive(PROTOCOL, 1)
        if senderId then
            print(string.format("[%s] Turtle %d: %s", 
                os.date("%H:%M:%S"), senderId, message.type or "unknown"))
            handleRequest(senderId, message)
            
            -- Show ore count after handling request
            if message.type == "request_path" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "ore_mined" then
                print(string.format("  -> Ores remaining: %d", #mapData.ores))
            elseif message.type == "request_scan" then
                print(string.format("  -> Scanned blocks, total ores: %d", #mapData.ores))
            end
        end
        
        -- Auto-save
        if os.clock() - lastSave >= AUTO_SAVE_INTERVAL then
            saveMap()
            lastSave = os.clock()
            print(string.format("[%s] Map auto-saved (%d ores)", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
        
        -- Periodic status update
        if os.clock() - lastStatus >= 60 then
            lastStatus = os.clock()
            print(string.format("[%s] Status: %d ores tracked", 
                os.date("%H:%M:%S"), #mapData.ores))
        end
    end
end
