-- SmartMiner Computer Brain (Advanced Computer + Geo Scanner + Basalt GUI)
-- Features: A* pathfinding, map persistence, real-time GUI, request-response protocol

----------------------------------
-- CONFIGURATION
----------------------------------
local scannerSide = "right"          -- side where geo scanner is attached
local modemSide = "left"             -- side where wireless modem is attached
local memorySide = "back"            -- side with memory card
local BASALT = true                  -- set true if Basalt installed
local SCAN_RADIUS = 8                -- scanner radius
local MAP_SAVE_KEY = "minerMap"
local AUTO_SAVE_INTERVAL = 30        -- seconds
local PROTOCOL = "smartminer"        -- rednet protocol

-- IDs and networking
local COMPUTER_ID = os.getComputerID and os.getComputerID() or 1
local TURTLE_TIMEOUT = 5

----------------------------------
-- PERIPHERALS SETUP
----------------------------------
local scanner = peripheral.wrap(scannerSide)
local modem = peripheral.wrap(modemSide)
local mem = peripheral.wrap(memorySide)

if not scanner then
    print("WARNING: Geo scanner not found on " .. scannerSide)
end

-- Ensure rednet open
if modem and peripheral.getType(modemSide):find("modem") then
    rednet.open(modemSide)
else
    print("Warning: modem not found on " .. modemSide)
end

----------------------------------
-- MAP DATA STRUCTURE
----------------------------------
local mapData = {
    visited = {},       -- ["x,y,z"] = true
    blocks = {},        -- ["x,y,z"] = blockName
    ores = {},          -- list of {x,y,z,name,claimed=false}
    home = {x=0,y=0,z=0},
}

----------------------------------
-- HELPERS
----------------------------------
local function keyFrom(x,y,z) 
    return x..","..y..","..z 
end

local function saveMap()
    if mem and mem.write then
        local ok, err = pcall(function() 
            mem.write(MAP_SAVE_KEY, textutils.serialize(mapData)) 
        end)
        if not ok then
            print("Save error:", err)
        end
    end
end

local function loadMap()
    if mem and mem.read and mem.list then
        local list = mem.list()
        if list and list[MAP_SAVE_KEY] then
            local ok, dat = pcall(function() 
                return textutils.unserialize(mem.read(MAP_SAVE_KEY)) 
            end)
            if ok and type(dat)=="table" then 
                mapData = dat 
                print("Map loaded from memory card")
            end
        end
    end
end

-- Load map on startup
loadMap()

----------------------------------
-- SCANNER WRAPPER
----------------------------------
local function doScan(radius)
    if not scanner or not scanner.scan then 
        print("No scanner available!")
        return {} 
    end
    local ok, res = pcall(function() return scanner.scan(radius) end)
    if not ok or not res then 
        print("Scan failed:", res)
        return {} 
    end
    return res
end

-- Ore definitions (supports both normal and deepslate)
local ORE_NAMES = {
    "minecraft:iron_ore", "minecraft:deepslate_iron_ore",
    "minecraft:coal_ore", "minecraft:deepslate_coal_ore",
    "minecraft:gold_ore", "minecraft:deepslate_gold_ore",
    "minecraft:diamond_ore", "minecraft:deepslate_diamond_ore",
    "minecraft:emerald_ore", "minecraft:deepslate_emerald_ore",
    "minecraft:redstone_ore", "minecraft:deepslate_redstone_ore",
    "minecraft:lapis_ore", "minecraft:deepslate_lapis_ore",
    "minecraft:copper_ore", "minecraft:deepslate_copper_ore",
}

local function isOre(blockName)
    for _, ore in ipairs(ORE_NAMES) do
        if blockName == ore then return true end
    end
    return false
end

local function addOresFromScan(scanList, scanX, scanY, scanZ)
    scanX = scanX or 0
    scanY = scanY or 0
    scanZ = scanZ or 0
    
    for _, b in ipairs(scanList) do
        -- Convert to absolute coordinates
        local absX, absY, absZ = scanX + b.x, scanY + b.y, scanZ + b.z
        
        -- Store block info
        mapData.blocks[keyFrom(absX, absY, absZ)] = b.name
        
        -- Add ores
        if isOre(b.name) then
            local k = keyFrom(absX, absY, absZ)
            local exists = false
            for _,o in ipairs(mapData.ores) do 
                if o.x==absX and o.y==absY and o.z==absZ then 
                    exists=true
                    break 
                end 
            end
            if not exists then
                table.insert(mapData.ores, {
                    x=absX, 
                    y=absY, 
                    z=absZ, 
                    name=b.name, 
                    claimed=false
                })
            end
        end
    end
    saveMap()
end

----------------------------------
-- A* PATHFINDER (3D)
----------------------------------
local function neighbors(node)
    local x,y,z = node.x, node.y, node.z
    return {
        {x=x+1, y=y, z=z, dir="east"},
        {x=x-1, y=y, z=z, dir="west"},
        {x=x, y=y+1, z=z, dir="up"},
        {x=x, y=y-1, z=z, dir="down"},
        {x=x, y=y, z=z+1, dir="south"},
        {x=x, y=y, z=z-1, dir="north"},
    }
end

local function isBlocked(x,y,z)
    local name = mapData.blocks[keyFrom(x,y,z)]
    if not name then return false end
    -- treat known liquids/bedrock as blocked
    if name:find("lava") or name:find("water") or name=="minecraft:bedrock" then 
        return true 
    end
    return false
end

local function heuristic(a,b)
    return math.abs(a.x-b.x) + math.abs(a.y-b.y) + math.abs(a.z-b.z)
end

local function computePath(start, goal)
    local open = {}
    local openMap = {}
    local cameFrom = {}
    local gScore = {}
    local fScore = {}
    
    local function push(node)
        table.insert(open, node)
        openMap[keyFrom(node.x, node.y, node.z)] = true
    end
    
    local function popLowest()
        local bestIdx, bestF = 1, math.huge
        for i, node in ipairs(open) do
            local k = keyFrom(node.x, node.y, node.z)
            if fScore[k] and fScore[k] < bestF then 
                bestF = fScore[k]
                bestIdx = i 
            end
        end
        local node = table.remove(open, bestIdx)
        if node then 
            openMap[keyFrom(node.x, node.y, node.z)] = nil 
        end
        return node
    end
    
    local startKey = keyFrom(start.x, start.y, start.z)
    gScore[startKey] = 0
    fScore[startKey] = heuristic(start, goal)
    push({x=start.x, y=start.y, z=start.z})

    local iterations = 0
    local maxIterations = 10000
    
    while #open > 0 and iterations < maxIterations do
        iterations = iterations + 1
        local current = popLowest()
        
        if current.x==goal.x and current.y==goal.y and current.z==goal.z then
            -- reconstruct path
            local path = {}
            local curKey = keyFrom(current.x, current.y, current.z)
            while curKey do
                table.insert(path, 1, {x=current.x, y=current.y, z=current.z})
                local c = cameFrom[curKey]
                if not c then break end
                current = c
                curKey = keyFrom(current.x, current.y, current.z)
            end
            return path
        end
        
        for _, n in ipairs(neighbors(current)) do
            if not isBlocked(n.x, n.y, n.z) then
                local nk = keyFrom(n.x, n.y, n.z)
                local currentKey = keyFrom(current.x, current.y, current.z)
                local tentative = gScore[currentKey] + 1
                
                if not gScore[nk] or tentative < gScore[nk] then
                    cameFrom[nk] = current
                    gScore[nk] = tentative
                    fScore[nk] = tentative + heuristic(n, goal)
                    if not openMap[nk] then 
                        push({x=n.x, y=n.y, z=n.z}) 
                    end
                end
            end
        end
    end
    
    return nil -- no path found
end

----------------------------------
-- MESSAGE PROTOCOL HANDLERS
----------------------------------
local function handleRequest(id, msg)
    if type(msg) ~= "table" or not msg.type then 
        return 
    end

    if msg.type == "request_scan" then
        print(string.format("[%d] Scan request from turtle %d", os.time(), id))
        local scanX, scanY, scanZ = msg.x or 0, msg.y or 0, msg.z or 0
        local scan = doScan(SCAN_RADIUS)
        addOresFromScan(scan, scanX, scanY, scanZ)
        rednet.send(id, { 
            type = "scan_result", 
            ores = mapData.ores,
            scanned = #scan 
        }, PROTOCOL)
        print(string.format("  Sent %d ores to turtle", #mapData.ores))

    elseif msg.type == "request_path" then
        print(string.format("[%d] Path request from turtle %d", os.time(), id))
        local cx, cy, cz = msg.x, msg.y, msg.z
        print(string.format("  Turtle at: %d,%d,%d", cx, cy, cz))
        
        -- choose nearest unclaimed ore
        local bestIdx, bestDist = nil, math.huge
        for i, o in ipairs(mapData.ores) do
            if not o.claimed and not mapData.visited[keyFrom(o.x, o.y, o.z)] then
                local dx = o.x - cx
                local dy = o.y - cy
                local dz = o.z - cz
                local dist = math.abs(dx) + math.abs(dy) + math.abs(dz)
                if dist < bestDist then 
                    bestDist = dist
                    bestIdx = i 
                end
            end
        end
        
        if not bestIdx then
            print("  No available ores")
            rednet.send(id, { 
                type = "path", 
                steps = {} 
            }, PROTOCOL)
            return
        end
        
        -- mark claimed to avoid races
        mapData.ores[bestIdx].claimed = true
        saveMap()

        local target = mapData.ores[bestIdx]
        print(string.format("  Target ore: %s at %d,%d,%d", target.name, target.x, target.y, target.z))
        
        -- compute path with A*
        local path = nil
        local ok, res = pcall(function() 
            return computePath(
                {x=cx, y=cy, z=cz}, 
                {x=target.x, y=target.y, z=target.z}
            ) 
        end)
        
        if ok and res then
            path = res
            print(string.format("  Path found: %d steps", #path))
        else
            path = {}
            print("  Path computation failed:", res)
        end
        
        rednet.send(id, { 
            type = "path", 
            steps = path, 
            target = target 
        }, PROTOCOL)

    elseif msg.type == "ore_mined" then
        print(string.format("[%d] Ore mined report from turtle %d", os.time(), id))
        local ox, oy, oz = msg.x, msg.y, msg.z
        mapData.visited[keyFrom(ox, oy, oz)] = true
        
        -- remove ore from list
        for i, o in ipairs(mapData.ores) do
            if o.x==ox and o.y==oy and o.z==oz then 
                print(string.format("  Removed ore: %s at %d,%d,%d", o.name, ox, oy, oz))
                table.remove(mapData.ores, i)
                break 
            end
        end
        saveMap()
        
        -- Send acknowledgment
        rednet.send(id, {
            type = "ack",
            remaining = #mapData.ores
        }, PROTOCOL)
    end
end

----------------------------------
-- BASALT GUI (OPTIONAL)
----------------------------------
if BASALT then
    print("Initializing Basalt GUI...")
    local ok, basalt = pcall(require, "basalt")
    
    if not ok then
        print("Basalt not available, using text mode")
        BASALT = false
    else
        -- Try to create a simple GUI, fall back to text mode if it fails
        local guiOk = pcall(function()
            local main = basalt.createFrame()
            
            -- Simple text display areas
            local infoBox = main:addLabel()
            infoBox:setPosition(1, 1)
            infoBox:setSize(50, 1)
            infoBox:setBackground(colors.black)
            infoBox:setForeground(colors.yellow)
            
            local oreListBox = main:addLabel()
            oreListBox:setPosition(1, 3)
            oreListBox:setSize(50, 15)
            oreListBox:setBackground(colors.black)
            oreListBox:setForeground(colors.white)
            
            local function updateDisplay()
                -- Info line
                infoBox:setText(string.format(
                    "SmartMiner | Ores: %d | Computer ID: %d", 
                    #mapData.ores, COMPUTER_ID
                ))
                
                -- Ore list
                local text = "Recent Ores:\n"
                local maxOres = math.min(12, #mapData.ores)
                for i = 1, maxOres do
                    local o = mapData.ores[i]
                    local oreName = o.name:match("(%w+)_ore") or "ore"
                    local stat = o.claimed and "[C]" or "[ ]"
                    text = text .. string.format("%s %s at %d,%d,%d\n", 
                        stat, oreName, o.x, o.y, o.z)
                end
                if #mapData.ores > 12 then
                    text = text .. string.format("...and %d more", #mapData.ores - 12)
                end
                oreListBox:setText(text)
            end
            
            -- Update timer
            local timer = main:addTimer()
            timer:setTime(1)
            timer:onCall(function()
                updateDisplay()
            end)
            timer:start()
            
            -- Quit handler
            main:onKey(function(_, key)
                if key == keys.q then
                    basalt.stop()
                end
            end)
            
            print("Basalt GUI started. Press Q to quit.")
            updateDisplay()
            
            -- Run Basalt alongside rednet handling
            parallel.waitForAny(
                function() basalt.autoUpdate() end,
                function()
                    while true do
                        local senderId, message = rednet.receive(PROTOCOL)
                        if senderId then
                            handleRequest(senderId, message)
                            updateDisplay()
                        end
                    end
                end,
                function()
                    -- Auto-save
                    while true do
                        sleep(AUTO_SAVE_INTERVAL)
                        saveMap()
                    end
                end
            )
        end)
        
        if not guiOk then
            print("GUI initialization failed, using text mode")
            BASALT = false
        end
    end
end

----------------------------------
-- TEXT MODE (NO BASALT)
----------------------------------
if not BASALT then
    print("═══════════════════════════════════")
    print("  SMARTMINER COMPUTER BRAIN")
    print("═══════════════════════════════════")
    print("Computer ID:", COMPUTER_ID)
    print("Protocol:", PROTOCOL)
    print("Scanner:", scanner and "OK" or "NOT FOUND")
    print("Modem:", modem and "OK" or "NOT FOUND")
    print("Memory:", mem and "OK" or "NOT FOUND")
    print("")
    print("Listening for turtle requests...")
    print("Press Ctrl+T to stop")
    
    local lastSave = os.epoch("utc")
    
    while true do
        local senderId, message, protocol = rednet.receive(PROTOCOL, 1)
        if senderId then
            print(string.format("[%d] Request from turtle %d", os.time(), senderId))
            handleRequest(senderId, message)
        end
        
        -- Auto-save
        local now = os.epoch("utc")
        if now - lastSave >= AUTO_SAVE_INTERVAL * 1000 then
            saveMap()
            lastSave = now
            print("Map auto-saved")
        end
    end
end
